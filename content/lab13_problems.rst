Декоратор, наблюдатель. Задачи.
###############################

:date: 2018-11-26 13:00
:summary: Задачи. Декоратор, наблюдатель
:status: published
:published: no

.. default-role:: code

.. contents:: Содержание


.. role:: python(code)
   :language: python


Задача №1
---------

Представьте себя ненадолго разработчиком компьютерной игры в стиле фэнтези.
Вы будете прописывать систему эффектов, которые могут быть наложены на героя вашей игры.

У вас есть герой, который обладает некоторым набором характеристик.
Враги и союзники могут накладывать на героя положительные и отрицательные эффекты.
Эти эффекты каким-то образом изменяют характеристики героя.
На героя можно накладывать бесконечно много эффектов, действие одинаковых эффектов суммируется.
Игрок должен знать, какие положительные и какие отрицательные эффекты на него были наложены и в каком порядке.

Класс герой описан следующим образом (характеристики могут быть другими):

.. code-block:: python

    class Hero:
    def __init__(self):
        self.positive_effects = []
        self.negative_effects = []
        
        self.stats = {
            "HP": 128,
            "MP": 42,
            "SP": 100,
            
            "Strength": 15,
            "Perception": 4,
            "Endurance": 8,
            "Charisma": 2,
            "Intelligence": 3,
            "Agility": 8,
            "Luck": 1
        } 
        
    def get_positive_effects(self):
        return self.positive_effects.copy()
    
    def get_negative_effects(self):
        return self.negative_effects.copy()
    
    def get_stats(self):
        return self.stats.copy()
        
    # ... и прочие функции

Описывать класс героя в коде **НЕ НУЖНО**.

Вам нужно написать систему декораторов, представленную на UML-диаграмме:

.. image:: {filename}/images/lab13/

Названия наложенных положительных и отрицательных эффектов добавляются каждое в свой счетчик.
Названия эффектов совпадают с названиями классов.

Описания эффектов:

* **Берсерк** — Увеличивает параметры Сила, Выносливость, Ловкость, Удача на 7; уменьшает параметры Восприятие, Харизма, Интеллект на 3. Количество единиц здоровья увеличивается на 50.
* **Благословение** — Увеличивает все основные характеристики на 2.
* **Слабость** — Уменьшает параметры Сила, Выносливость, Ловкость на 4.
* **Сглаз** — Уменьшает параметр Удача на 10.
* **Проклятье** — Уменьшает все основные характеристики на 2.

К основным характеристикам относятся Сила (Strength), Восприятие (Perception), Выносливость (Endurance), Харизма (Charisma), Интеллект (Intelligence), Ловкость (Agility), Удача (Luck).

При выполнении задания учитывайте, что:

Изначальные характеристики базового объекта **не должны меняться**.
Изменения характеристик и накладываемых эффектов (баффов/дебаффов) должно происходить динамически,
то есть в момент запросов :python:`Hero.get_stats(), Hero.get_positive_effects(), Hero.get_negative_effects()`

Абстрактные классы :python:`AbstractPositive, AbstractNegative` и соответственно их потомки могут принимать любой параметр :python:`base`
при инициализации объекта (:python:`Class.__init__(self, base)`)

*Проверяйте, что эффекты корректно снимаются, в том числе и из середины стека*

.. code-block:: python

    class AbstractEffect(Hero, ABC):
    def __init__(self, base):
        self.base = base
    
    def get_stats(self): # Возвращает итоговые характеристики
                         # после применения эффекта
        pass

    def get_positive_effects(self):
        pass

    def get_negative_effects(self):
        pass


для отправки задачи исполльзуйте 

.. code-block:: bash

    wget -qO - --post-file=<filename> http://10.55.169.100:5000/decorator.py/<name>


Упражнение №2
-------------

Продолжая работу над игрой, вы добрались до системы достижений.
Иногда игре нужно наградить игрока за то, что он достигает определенного результата в игре.
Это может быть, например, прохождение всех заданий в игре, достижение определенного уровня, совершение какого-то сложного действия и т.д.

У каждой игры есть движок и интерфейс пользователя.
Это два компонента, которые работают параллельно и взаимодействуют друг с другом.
Достижения генерируются движком игры, а отображаются пользовательским интерфейсом.
Кроме того, на современных игровых площадках, таких как Steam, Google Play, также отображаются достижения, полученные игроком.
Для этого применяется как раз паттерн Наблюдатель.

У вас есть движок :python:`Engine`, который может создавать уведомления о достижениях.
Вам необходимо написать обертку над движком, которая будет иметь возможность подписывать наблюдателей и рассылать им уведомления, а также иерархию наблюдателей.
В иерархию наблюдателей должны входить абстрактный наблюдатель, :python:`AbstractObserver`, от которого унаследованы 2 наблюдателя :python:`ShortNotificationPrinter` и :python:`FullNotificationPrinter`.
Первый из них составляет множество названий полученных достижений, второй составляет список достижений в том порядке, в котором они даны в системе.
Имейте в виду, что каждое достижение должно быть учтено только один раз.

Иерархия классов приведена на следующей UML диаграмме:

.. image:: {filename}/images/lab13/obs_problem.jpeg


Пример достижения, которое генерирует движок:

.. code-block:: json

    {"title": "Покоритель", "text": "Дается при выполнении всех заданий в игре"}

Метод :python:`update` не должен возвращать никаких значений, он должен только изменять переменную :python:`achievements`.

Класс :python:`Engine` реализовывать не нужно!

для отправки задачи исполльзуйте 

.. code-block:: bash

    wget -qO - --post-file=<filename> http://10.55.169.100:5000/observer.py/<name>