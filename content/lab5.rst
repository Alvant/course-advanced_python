Объектно-ориентированное программирование. Python.
################

:date: 2019-09-29 19:00
:summary: Тема 5. Объектно-ориентированное программирование. Python.
:status: published

.. default-role:: code

.. role:: python(code)
   :language: python
   
.. contents::

.. code:: python`

    import numpy as np

Понятие объекта и класса
========================

Класс – это прототип сложной структуры, определяющий состояние и
поведение, зависящее от этого состояния. В понитие класса также входят и
правила для взаимодействия с данной структурой. Если проще, то класс -
структура, состояая из набора данных (полей, атрибутов, членов класса) и
функций для работы с ними (методов).

Зачем это нужно: - Для создания сложной структуры данных со сложным
поведением; - Для поддержки механизмов инкапсуляции, полиморфизма и
наследования; - Для удобства. Большая задача разбивается на много
функциональных блоков меньшего размера, каждый из который реализуется
классом.

Объект (экземпляр) – это конкретный экзмпляр-представитель класса,
имеющий конкретное состояние и поведение, полностью определяемое своим
прототипом-классом.

Python соответствует принципам объектно-ориентированного
программирования. В python всё является объектами - и строки, и списки,
и словари, и всё остальное.

Для простого примера создадим класс робота, собирающего разбросанные на
клеточном поле шарики и свозящим их в свое хранилище.

.. code:: python

    class robot:
    
        def __init__(self): # специальная функция инициализации робота-сборщика.
                            # Выполнится автоматически первой при создании объекта
            
            self.velocity = np.array([1,1]) #скорость перемещения (на сколько клеточек за 1 ход может переместиться по Х и У)
            self.maxcapacity = 1 #максимальная вместимость (сколько шариков(например) может перевозить)
            self.filling = 0 #насколько заполнен багажник робота в определенный момент времени
            self.state = -1 #состояние робота в определенный момент времени
            
        def action1(self): # self - обязательный аргумент, содержащий в себе экземпляр
                           # класса, передающийся при вызове метода,
                           # поэтому этот аргумент должен присутствовать
                           # во всех методах класса.
            print('Приступаю к выполнению действия1')
            # код, описывающий действие робота. Действие робота может приводить к изменению среды и состояния самого робота
            print('Выполнил действие1')
            
        def action2(self):
            print('Приступаю к выполнению действия2')
            # код, описывающий действие робота. Действие робота может приводить к изменению среды и состояния самого робота
            return 'Выполнил действие2'
        
        def action3(self):
            pass # можно оставлять конструкцию pass, чтобы потом дополнить кодом.

Далее можно создать 2 робота по написанному прототипу класса и заставить
выполнить по какому-нибудь действию

.. code:: python

    rob_101 = robot()
    rob_101.action1()


.. parsed-literal::

    Приступаю к выполнению действия1
    Выполнил действие1
    

.. code:: python

    rob_102 = robot()
    rob_102.action2()


.. parsed-literal::

    Приступаю к выполнению действия2
    



.. parsed-literal::

    'Выполнил действие2'



Парадигмы ООП - инкапсуляция, наследование и полиморфизм
========================================================

Абстрагирование – это способ выделить набор значимых характеристик
объекта, исключая из рассмотрения незначимые. Соответственно, абстракция
– это набор всех таких характеристик.

Инкапсуляция – это свойство системы, позволяющее объединить(упаковать)
данные и методы (функции) в единый компонент - класс. В общем случае, в
разных языках программирования термин «инкапсуляция» относится к одному
из или обоим определениям: - механизм языка, позволяющий ограничить
доступ одних компонентов программы к другим. Например, ограничивается
доступ к переменным объекта класса. В Python, чтобы создать в классе
скрытую переменную, такую переменную, что к ней имеют доступ только
методы самого класса, нужно перед именем переменной поставить \_\_ (два
подчеркивания). - языковая конструкция, позволяющая связать данные с
методами, предназначенными для обработки этих данных.

.. code:: python

    # coding=UTF-8
    class TestClass:
    
        def __init__(self):
            self.public_variable = "I'm public!"
            self.__private_variable = "I'm too shy to be public!"
    
        def get_public_variable(self):
            return self.public_variable
    
        def get_private_variable(self):
            return self.__private_variable
    
    if __name__ == "__main__":
        test_class = TestClass()
        print(" ".join(["Public variable:", test_class.get_public_variable()]))
        print(" ".join(["Public variable:", test_class.public_variable]))
    
        print(" ".join(["Private variable:", test_class.get_private_variable()]))
        print(" ".join(["Private variable:", test_class._private_variable]))


.. parsed-literal::

    Public variable: I'm public!
    Public variable: I'm public!
    Private variable: I'm too shy to be public!
    

::


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-32-d69b047b6abf> in <module>()
         18 
         19     print(" ".join(["Private variable:", test_class.get_private_variable()]))
    ---> 20     print(" ".join(["Private variable:", test_class._private_variable]))
    

    AttributeError: 'TestClass' object has no attribute '_private_variable'


Удобство инкапсуляции в следующем: - Безопасность: никто не может
залезть внутрь класса и записать в переменные все что захочет, тем
самым, сломав вашу программу; - Удобство: рефакторинг (переписывании
кода). Вы можете начать переписывать класс, переназвать переменные и вам
не придется бегать по коду и менять везде ``test_class.public_variable``
на ``test_class.new_public_variable``, вам нужно будет поменять всего
одну функцию ``get_public_variable``.

Абстрактный тип данных (АТД) - это такой тип данных, который скрывает
свою внутреннюю реализацию от клиентов. См. инкапсуляцию.

АДТ имеет следующие преимущества:

-  Инкапсуляция деталей реализации. Это означает, что единожды
   инкапсулировав детали реализации работы АТД мы предоставляем клиенту
   интерфейс (методы класса, которые позволяют взаимодействовать с его
   непосредственным внутренним содержанием, не раскрывая его. В случае
   PositiveInt это get\_a(self) и set\_a(self, a)), при помощи которого
   он может взаимодействовать с АТД. Изменив детали реализации,
   представление клиентов о работе АТД не изменится.
-  Снижение сложности. Путем абстрагирования от внутренней реализации
   класса мы сосредотачиваемся на интерфейсе, т.е на том, что может
   делать АТД, а не на том, как это делается.
-  Ограничение области использования данных. Используя АТД, мы можем
   быть уверены, что данные, представляющие внутреннюю структуру АТД, не
   будут зависеть от других участков кода. При этом реализуется
   “независимость” АТД.
-  Высокая информативность интерфейса. АТД позволяет представить весь
   интерфес в терминах сущностей предметной области, что, согласитесь,
   повышает удобочитаемость и информативность интерфейса.

Наследование – это свойство системы, позволяющее описать новый класс на
основе уже существующего с частично или полностью заимствующейся
функциональностью. Класс, от которого производится наследование,
называется базовым или родительским. Новый класс – потомком, наследником
или производным классом.

Рассмотрим простое наследование, пусть класс Derived --> Base.

.. code:: python

    class Base:
        pass
    
    class Derived(Base):
        pass

Класс ``Base`` в данном случае является **базовым классом, родительским
классом, надклассом, суперклассом, предком**.

Класс ``Derived`` по отношению к нему является **производным классом,
дочерним классом, подклассом, потомком**.

Говорят, что ``Derived`` **наследует, расширяет или специализирует**
``Base``.

В языке Python 3 существует единый базовый класс object, который неявно
является предком всех объектов вообще.

Класс Object определяет базовые методы всех классов, они могут быть
переопределены у конкретного класса..

Давайте рассмотрим пример, когда это может понадобиться:

.. code:: python

    class Student(UniversityMember):
        group = None
        passToUniversity = ''
        status = True
    
        def checkStatus(self):
            return self.status
    
        def dismiss(self):
            self.status = False
            self.pass_to_university = None
    
    class Teacher(UniversityMember):
        cathedral = None
        passToUniversity = ''
        status = True
    
        def checkStatus(self):
            return self.status
    
        def dismiss(self):
            self.status = False
            self.pass_to_university = None
    
    class Administrator(UniversityMember):
        passToUniversity = ''
        status = True
    
        def checkStatus(self):
            return self.status
    
        def dismiss(self):
            self.status = False
            self.pass_to_university = None

В данном случае и у студента, и у преподавателя, и у администратора
должны быть свойства ``status`` и ``pass_to_university``, возможность
проверки статуса и возможность увольнения.

Можно заметить, что в примере очень много дублирующегося кода. Это
плохо. Если мы захотим что-то поменять, нам придется менять в трех
местах как минимум. Если забудем что-то поменять, то это приведет к
ошибке. В масштабах большого программного продукта это приведет к
катастрофе.

.. code:: python

    class UniversityMember:
        passToUniversity = ''
        status = True
    
        def checkStatus(self):
            return self.status
    
        def dismiss(self):
            self.status = False
            self.pass_to_university = None
    
    class Student(UniversityMember):
        group = None
    
    class Teacher(UniversityMember):
        cathedral = None
    
    class Administrator(UniversityMember):
        pass

**Перегрузка методов**

Любой метод можно переопределить, то есть повторно реализовать в
подклассе. В этом случае для экземпляров базового класса будет
вызываться базовый метод, а для экземпляров производного -
перегруженный.

.. code:: python

    class Base:
        def hello(self):
            print("Hello! I'm base class!")
    
    class Derived(Base):
        def hello(self):
            print("Hello! I'm derived class!")
    
    b = Base()
    d = Derived()

.. code:: python

    b.hello()   # Hello! I'm base class!
    d.hello()   # Hello! I'm derived class!


.. parsed-literal::

    Hello! I'm base class!
    Hello! I'm derived class!
    

Этот механизм называется динамическим **связыванием методов** или
**полиморфизмом**.

**Полиморфизм** – это свойство системы использовать объекты с одинаковым
интерфейсом без информации о типе и внутренней структуре объекта.

Множественное наследование: При множественном наследовании у класса
может быть более одного предка. В этом случае класс-потомок наследует
методы всех предков.

.. code:: python

    class SuperBase: # Предок предка
        def do(self):
            print('Метод суперпредка!')
    class Base1(SuperBase):   # Предок 1
        def do_it(self):
            print('Метод предка 1')
    class Base2:   # Предок 2
        def do_it(self):
            print('Метод предка 2')
    class Derived(Base1, Base2):   # Наследник
        def do_it_by_myself(self):
            print('Метод наследника')
    
    d = Derived()   # инстанциация
    
    d.do_it_by_myself()  # Если в классе-потомке есть перегруженный метод с искомым названием
                         # то он будет вызван независимо от наличия таких же методов у предков.
    
    d.do_it() # Если такого метода нет, то он ищется в порядке "лествичного права":
              # в первую очередь у ближайших предков -- слева-направо,
              # затем у их предков в том же порядке слева-направо, пока не будет найден.
              # В данном случае будет вызван метод предка 1.
    
    d.do()  # Метод суперпредка вызывается, только если такого нет
            # ни у класса, ни у его ближайших предков


.. parsed-literal::

    Метод наследника
    Метод предка 1
    Метод суперпредка!
    

SOLID-принципы
==============

Принцип единственной обязанности (ответственности) (Single Responsibility Principle)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Один класс должен решать только какую-то одну задачу. Он может иметь
несколько методов, но они должны использоваться лишь для решения общей
задачи. Все методы и свойства должны служить одной цели. Все его сервисы
должны быть направлены исключительно на решение этой задачи. Если класс
имеет несколько назначений, его нужно разделить на отдельные классы.

Принцип открытости/закрытости (Open-closed Principle)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Программные сущности (классы, модули, функции и прочее) должны быть
расширяемыми без изменения своего содержимого. Если строго соблюдать
этот принцип, то можно регулировать поведение кода без изменения
исходного кода.

Подстановочный критерий Барбары Лисков (Принцип подстановки) (Liskov Substitution Principle)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Подкласс/производный класс должен быть взаимозаменяем с
базовым/родительским классом.

Подстановочный критерий Барбары Лисков гласит также, что класс-потомок
не только должен уметь делать всё то же, что и предок, но и не должен
требовать для этого ничего нового.

Роберт С. Мартин определил этот принцип так:

*Функции, которые используют базовый тип, должны иметь возможность
использовать подтипы базового типа, не зная об этом»*. Идея в том, чтобы
выделять в отдельный класс все не специфические для объектов свойства, и
наследоваться уже от этого универсального класса. Т.е. в базовый класс,
от которого наследуются, могут добавляться только те поля и методы,
которые нужны всем наследникам. В таком случае, если вы возьмете
функцию, которая использует класс А, возьмете класс В, который
унаследован он А и передадите в эту функцию, все будет работать.

Грубо говоря, если электрик чинил розетку за рубли, то его потомок
должен, во-первых, уметь чинить розетку, во-вторых, уметь получить за
это рубли (а не только доллары) и, в-третьих, не требовать для
выполнения своей работы предварительных "танцев с бубном" (специфических
предварительных инициализаций) или передачи дополнительных параметров в
виде коробки конфет или бутылки водки.

Принцип разделения интерфейса (Interface Segregation Principle)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Это означает, что нужно разбивать интерфейсы на более мелкие, лучше
удовлетворяющие конкретным потребностям клиентов.

в фор­му­ли­ровке Роберта Мар­ти­на: *«кли­енты не должны зави­сеть от
мето­дов, кото­рые они не исполь­зуют»*. Прин­цип раз­де­ле­ния
интер­фей­сов гово­рит о том, что слиш­ком «тол­стые» интер­фейсы
необ­хо­димо раз­де­лять на более малень­кие и спе­ци­фи­че­ские, чтобы
кли­енты малень­ких интер­фей­сов знали только о мето­дах, кото­рые
необ­хо­димы им в рабо­те. В ито­ге, при изме­не­нии метода интер­фейса
не должны меняться кли­енты, кото­рые этот метод не исполь­зуют.

Принцип инверсии зависимостей (Dependency Inversion Principle)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Высокоуровневые модули не должны зависеть от низкоуровневых. Оба вида
модулей должны зависеть от абстракций.

Абстракции не должны зависеть от подробностей. Подробности должны
зависеть от абстракций

Статические и классовые методы
==============================

https://proglib.io/p/python-oop/

Существуют 2 особенных декоратора, которые можно повесить на функции
внутри класса: - @staticmethod - @classmethod

Декоратор @staticmethod определяет обычную функцию (статический метод) в
пространстве имён класса. У него нет обязательных параметров-ссылок
вроде self. Может быть полезно для вспомогательных функций, чтобы не
мусорить пространство имён модуля. Доступ к таким методам можно получить
как из экземпляра класса, так и из самого класса:

.. code:: python

    class SomeClass(object):
      @staticmethod
      def hello():
        print("Hello, world")
    
    SomeClass.hello() # Hello, world
    obj = SomeClass()
    obj.hello() # Hello, world


.. parsed-literal::

    Hello, world
    Hello, world
    

Декоратор @classmethod создаёт метод класса и требует обязательную
ссылку на класс (cls). Поэтому объект класса явно передаётся через
первый параметр как это с параметром self происходит для обычных
методов. Также как и для self, переданный cls может отличаться от
класса, в котором определён класс-метод (может быть потомок). Часто
используется для создания альтернативных конструкторов.

.. code:: python

    class SomeClass(object):
      @classmethod
      def hello(cls):
        print('Hello, класс {}'.format(cls.__name__))
    
    SomeClass.hello() # Hello, класс SomeClass


.. parsed-literal::

    Hello, класс SomeClass
    

Давайте взглянем на пример кода, в котором одновременно показаны она
декоратора, это может помочь понять основные принципы:

.. code:: python

    class Person:
        def __init__(self, name, age):
            self.name = name
            self.age = age
    
        # classmethod чтобы создать объект по году рождения,
        # "альтернативный" конструктор
        @classmethod
        def fromBirthYear(cls, name, year):
            return cls(name, 2019 - year)
    
        # статический метод,чтобы проверить совершеннолетие
        @staticmethod
        def isAdult(age):
            return age > 18
    
    person1 = Person('Петя', 21)
    person2 = Person.fromBirthYear('Петя', 1996)
    
    print(person1.age)
    print(person2.age)
    
    # print the result
    print(Person.isAdult(22))


.. parsed-literal::

    21
    23
    True
    

**Важно понимать, что ни classmethod ни staticmethod НЕ являются
функциями от конкретного объекта класса и соответственно не принимают
self. Подчеркнем еще раз их различия:** - classmethod принимает cls как
первый параметр, тогда как staticmethod в специальных аргументах не
нуждается - classmethod может получать доступ или менять состояние
класса, в то время как staticmethod нет - staticmethod в целом вообще
ничего не знают про класс. Это просто функция над аргументами,
объявленная внутри класса.

Специальные методы (магические) вида \_ *< param >* \_
======================================================

В Python существует огромное количество специальных методов, расширяющих
возможности пользовательских классов. Например, можно определить вид
объекта на печати
(https://docs.python.org/3.7/reference/datamodel.html?highlight=getitem#object.**str**),
его "официальное" строковое представление
(https://docs.python.org/3.7/reference/datamodel.html?highlight=getitem#object.**repr**)
или поведение при сравнениях. Узнать о них подробнее вы можете в
официальной документации языка
(https://docs.python.org/3.7/reference/datamodel.html?highlight=getitem#special-method-names).

Эти методы могут эмулировать поведение встроенных классов, но при этом
они необязательно существуют у самих встроенных классов. Например, у
объектов int при сложении не вызывается метод **add**. Таким образом, их
нельзя переопределить.

Давайте для примера переопределим стандартную операцию сложения.
Рассмотрим класс Vector, используемый для представления радиус-векторов
на координатной плоскости, и определим в нем поля-координаты: x и y.
Также очень хотелось бы определить для векторов операцию +, чтобы их
можно было складывать столь же удобно, как и числа или строки.

Для этого необходимо перегрузить операцию +: определить функцию, которая
будет использоваться, если операция + будет вызвана для объекта класса
Vector. Для этого нужно определить метод **add** класса Vector, у
которого два параметра: неявная ссылка self на экземпляр класса, для
которого она будет вызвана (это левый операнд операции +) и явная ссылка
other на правый операнд:

.. code:: python

    class Vector():
        def __init__(self, x = 0, y = 0):
            self.x = x
            self.y = y
        def __add__(self, other):
            return Vector(self.x + other.x, self.y + other.y)
    
    A = Vector(1, 2)
    B = Vector(3, 4)
    C = A + B
    print(C.x, C.y)


.. parsed-literal::

    4 6
    

Теперь при вызове оператора A + B Питон вызовет метод A.\ **add**\ (B),
то есть вызовет указанный метод, где self = A, other = B.

Аналогично можно определить и оставшиеся операции. Полезной для
переопределения является операция <. Она должна возвращать логическое
значение True, если левый операнд меньше правого или False в противном
случае (также в том случае, если объекты равны). Для переопределения
этого операнда нужно определить метод **lt** (less than):

.. code:: python

    class Vector:
        def __lt__(self, other):
            return self.x < other.x or self.x == other.x and self.y < other.y

В этом примере оператор вернет True, если у левого операнда поле x
меньше, чем у правого операнда, а также если поля x у них равны, а поле
y меньше у левого операнда.

После определения оператора <, появляется возможность упорядочивать
объекты, используя этот оператор. Теперь можно сортировать списки
объектов при помощи метода sort() или функции sorted, при этом будет
использоваться именно определенный оператор сравнения <.

Список возможных перегружаемых операторов
https://docs.python.org/3.7/reference/datamodel.html?highlight=getitem#special-method-names

Абстрактные классы
==================

Абстрактным называется класс, который содержит один и более абстрактных
методов. Абстрактным называется объявленный, но не реализованный метод.
Абстрактные классы не могут быть инстанциированы, от них нужно
унаследовать, реализовать все их абстрактные методы и только тогда можно
создать экземпляр такого класса.

В python существует стандартная библиотека abc, добавляющая в язык
абстрактные базовые классы (АБК). АБК позволяют определить класс, указав
при этом, какие методы или свойства обязательно переопределить в
классах-наследниках.

Возьмем для примера, шахматы. У всех шахматных фигур есть общий
функционал, например - возможность фигуры ходить и быть отображенной на
доске. Исходя из этого, мы можем создать абстрактный класс Фигура,
определить в нем абстрактный метод (в нашем случае - ход, поскольку
каждая фигура ходит по-своему) и реализовать общий функционал (отрисовка
на доске).

.. code:: python

    from abc import ABC, abstractmethod
     
    class ChessPiece(ABC):
        # общий метод, который будут использовать все наследники этого класса
        def draw(self):
            print("Drew a chess piece")
     
        # абстрактный метод, который будет необходимо переопределять для каждого подкласса
        @abstractmethod
        def move(self):
            pass

.. code:: python

    a = ChessPiece() # Если мы попытаемся инстанциировать данный класс, логично получим ошибку.


::


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-91-1f9727e5cc03> in <module>()
    ----> 1 a = ChessPiece() # Если мы попытаемся инстанциировать данный класс, логично получим ошибку.
    

    TypeError: Can't instantiate abstract class ChessPiece with abstract methods move


Как видите, система не дает нам создать экземпляр данного класса. Теперь
нам необходимо создать конкретный класс, например, класс ферзя, в
котором мы реализуем метод move.

.. code:: python

    class Queen(ChessPiece):
        def move(self):
            print("Moved Queen to e2e4")
            
    # Мы можем создать экземпляр класса
    q = Queen()
    # И нам доступны все методы класса
    q.draw()
    q.move()


.. parsed-literal::

    Drew a chess piece
    Moved Queen to e2e4
    

Обратите внимание, абстрактный метод может быть реализован сразу в
абстрактном классе, однако, декоратор abstractmethod, обяжет
программистов, реализующих подкласс либо реализовать собственную версию
абстрактного метода, либо дополнить существующую. В таком случае, мы
можем переопределять метод как в обычном наследовании, а вызывать
родительский метод при помощи super().

.. code:: python

    from abc import ABC, abstractmethod
     
    class Basic(ABC):
        @abstractmethod
        def hello(self):
            print("Hello from Basic class")
    
    
    class Advanced(Basic):
        def hello(self):
            super().hello()
            print("Enriched functionality")
    
    
    a = Advanced()
    a.hello()


.. parsed-literal::

    Hello from Basic class
    Enriched functionality
    

Таким образом, используя концепцию абстрактных классов, мы можем
улучшить качество архитектуры приложения, уменьшить объем работы и при
этом, обеспечить легкость дальнейшей поддержки кода.

подробности можно найти в документации:
https://docs.python.org/3/library/abc.html

Декомпозиция программы на модули
================================

Модули и пакеты в Python – это прекрасные инструменты для управления
сложностью в программном проекте.

Создадим модуль с именем simplemath.py, который будет содержать функции
для выполнения простых арифметических действий.

Создадим ещё один модуль worker.py, который будет использовать функции
из simplemath.py. Если мы хотим импортировать все функции, то оператор
import для нас отлично подойдет. Это будет выглядеть так.

.. code:: python

    # представим, что эта ячейка - текстовый редактор, который мы сохраним под именем simplemath.py
    def add(a, b):
        return a + b
    
    def sub(a, b):
        return a - b
    
    def mul(a, b):
        return a * b
    
    def div(a, b):
        return a / b

.. code:: python

    # представим, что эта ячейка - текстовый редактор, который мы сохраним под именем simplemath.py
    
    #import simplemath
    #from simplemath inpord add,sub,mul,div
    
    #print(simplemath.add(1, 2)) # = 3
    #print(simplemath.sub(1, 2)) # = -1
    #print(simplemath.mul(1, 2)) # = 2
    #print(simplemath.div(1, 2)) # = 0.5

Упражнения/Задачи:
==================

могут быть изменены/дополнены вашим преподавателем (уточните)

Задача 1:
~~~~~~~~~

Реализуйте свой класс Complex для комплексных чисел, аналогично
встроенной реализации complex: 1. Добавьте конструктор класса 2.
Реализуйте операции проверки на равенство, сложения, вычитания,
произведения и деления комплексных чисел (**eq**, **add**, **sub**,
**mul**, **truediv**) 3. Реализуйте операцию модуля (**abs**, вызываемую
как \|c\|) 4. Оба класса должны давать осмысленный вывод как при print,
так и просто при вызове в ячейке

Задача 2:
~~~~~~~~~

Вам на вход приходит последовательность целых чисел. Вам надо
обрабатывать ее следующим образом: выводить на экран сумму первых пяти
чисел этой последовательности, затем следующих 5 итд

Но последовательность не дается вам сразу целиком. С течением времени к
вам поступают её последовательные части. Например, сначала первые три
элемента, потом следующие шесть, потом следующие два и т. д.

Реализуйте класс Buffer, который будет накапливать в себе элементы
последовательности и выводить сумму пятерок последовательных элементов
по мере их накопления.

Одним из требований к классу является то, что он не должен хранить в
себе больше элементов, чем ему действительно необходимо, т. е. он не
должен хранить элементы, которые уже вошли в пятерку, для которой была
выведена сумма.

Класс должен иметь следующий вид

.. code:: python

    class Buffer:
        def __init__(self):
            # конструктор без аргументов
        
        def add(self, *a):
            # добавить следующую часть последовательности

        def get_current_part(self):
            # вернуть сохраненные в текущий момент элементы последовательности в порядке, в котором они были     
            # добавлены

Задача 3:
~~~~~~~~~

| Создайте правильные цепочки наследования классов для: Животное,
  собака, щенок, самолет, компьютер, имеющее лапы, летающее, орел,
  белка-летяга, разумное, человек, медуза, одуванчик.
| В эти классы добавьте конструкторы, а также методы для следующих
  действий (где надо): полаять, родить, сложить два числа, ужалить,
  подумать, взлететь, пустить корни, поесть, взять, а также следующие
  поля: возраст, латинское название (или модель). Прокомментируйте вашу
  логику

Задача 4\* ДНК
~~~~~~~~~~~~~~

| Реализуйте классы для ДНК (двойная цепочк) и РНК (одинарная цепочка).
  Данные структуры данных должны поддерживать следующие возможности: 1.
  Создавать структуру из строк. Обратите внимание, что в ДНК встречаются
  только азотистые основания ATGC, а в РНК (AUGC) поэтому если во
  входной строке содержались другие символы, необходимо поднимать ошибку
  (Exception). 2. Поддерживают индексацию. РНК по индексу возвращает
  i-ое азотистое основание, ДНК - пару азотистых оснований
  (соответствующие первой и второй цепочке) 3. РНК может возвращать
  комплиментарную ДНК (каждому азотистому основанию из РНК соответсвует
  соответсвующее основание для первой цепочки ДНК: :math:`A \to T`,
  :math:`U \to A`, :math:`G \to C`, :math:`C \to G`. Вторая цепочка ДНК
  строится комплиментарной первой строчке ДНК: :math:`A \to T`,
  :math:`T \to A`, :math:`G \to C`, :math:`C \to G`) 4. РНК, как и ДНК,
  могут складываться путем склеивания ("AUUGAACUA" + "CGGAAA" =
  "AUUGAACUACGGAAA"). У ДНК склеиваются соответствующие цепочки (["ACG",
  "TGC"] + ["TTTAAT", "AAATTA"] = ["ACGTTTAAT", "TGCAAATTA"]) 5. РНК
  могут перемножаться друг с другом: каждое азотистое основание
  результирующей РНК получается случайным выбором одного из двух
  соответсвующих родительских азотистых оснований. Если одна из цепочек
  длиннее другой, то перемножение происходит с начала, когда одна из
  цепочек закончится оставшийся хвост другой переносится без изменений.
  |Умножение РНК| 6. ДНК могут перемножаться друг с другом: ПЕРВЫЕ
  цепочки каждой из ДНК перемножаются по такому же приницпу, как
  перемножаются РНК выше. Вторая цепочка результирующей ДНК строится как
  комплиментарная первой 7. Цепочки РНК и первую и вторую у ДНК можно
  проверять на равенство 8. Оба класса должны давать осмысленный вывод
  как при print, так и просто при вызове в ячейке
| **Обдумайте и создайте необходимые и, возможно, вспомогательные
  классы, настройте наследование, если требуется. Полученная структура
  должна быть адекватной и удобной, готовой к простому расширению
  функционала, если потребуется**

.. |Умножение РНК| image:: Умножение%20РНК.jpg

Материалы:
==========

-  https://github.com/mipt-cs/course-advanced\_python/blob/materials\_2018/content/lab11.rst
-  https://proglib.io/p/python-oop/
-  https://habr.com/ru/post/87119/
-  https://habr.com/ru/post/87205/
-  https://habr.com/ru/company/mailru/blog/412699/
-  https://habr.com/ru/post/72757/
-  https://devpractice.ru/python-modules-and-packages/

Пересобрал материалы: Клоков А.А. (aaklokov@yandex.ru,
https://github.com/Laggg)
