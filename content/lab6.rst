Работа со строками в языке C
############################

:date: 2018-10-08 10:00
:summary: Работа со строками в языке C
:status: published
:published: yes

.. default-role:: code

.. contents:: Содержание

.. role:: c(code)
   :language: c

Строки в языке **С**
====================

**Строки** — последовательность *символов*. В С представляет собой массив *символов* (:c:`char *`). При этом стоит помнить, что **символ** (:c:`char`) в С — число, соответствующее коду символа в кодовой таблице символов.

Однако у строки есть одно важное отличие от простого массива символов. На конце строки всегда находиться символ терминирующего нуля: '\0'. 

Объявление строк в языке **C**
==============================

Создать строку в языке С можно одним из следующих способов:

1. Создать массив символов фиксированного размера. **Не  забудьте, что необходимо оставить место под терминирующий нуль!**

.. code-block:: c
        
        char string[101];

2. Создать массив символов из строки. При этом стоит помнить, что **любая** последовательность символов, находящаяся в **двойных кавычках** будет рассматриваться компилятором языка C как строковая константа. Для указания компилятору, что имеется в виду одинарный символ :c:`char` необходимо использовать **одинарные кавычки** (:c:`'0' == 48`)

.. code-block:: c
        
        char string1[] = "Sample string";  // generate string from constant
        char string2[] = {'Y', 'e', 't', ' ', 'a', 'n', 'o', 't', 'h', 'e', 'r', ' ', 's', 't', 'r', 'i', 'n', 'g', '\0'}; // Don't forget \0 at the end!

3. Выделить место под массив символов. Этот способ аналогичен объявлению динамического массива.

.. code-block:: c
        
        char * string = (char *) malloc( 51 * sizeof(char));

**Не забудьте очистить выделенную память!**

Чтение и печать строк в командной строке
========================================

В языке C существует несколько способов считывания и вывода строк в консоль. Для этого необходимо подключить стандартную библиотеку ввода-вывода — `stdio.h`. 

Способы ввода строк
-------------------

1. **Используя команду `scanf`**. Для ввода сторк при помощи используется спецификатор `%s`. Перед работой необходимо выделить память под строку.

.. code-block:: c
        
        char * string = (char *) malloc(51);  // Maximum length: 50 + '\0'. We don't need to use 'sizeof(char)' as it is equal to 1
        scanf("%s", string);  // We don't use '&string' as 'string' is already a pointer

2. **Используя команду `gets` (`gets_s`)**. Для ввода строк может быть использована специальная функция :c:`char * gets(char *)`. Она считывает символы до символа переноса строки и помещает их в по указанному адресу. В конце добавляется символ терминирующего нуля.

.. code-block:: c
        
        char string[51];  // Max length: 50 + '\0'
        gets(string);

При вводе строк не забудьте выделить под них достаточно места. Функции ввода не проверяют, помещается ли строка в выделенную область и могут выйти за её границу. Это может в лучшем случае привести к ошибке, а в худшем дать возможность любому пользователю изменять данные программы по своему желанию.

Способы вывода строк
--------------------

1. **Вывод сторк используя `printf` со спецификатором**. Строки можно выводить используя функцию `printf`. Для вывода строк используется спецификатор `%s`. 

.. code-block:: c
        
        char string[] = "Example string";
        printf("String: %s", string);

2. **Вывод строк с использованием `printf`**. Можно выводить строку используя `printf` без спецификаторов.

.. code-block:: c
        
        char string[] = "Another string";
        printf(string);

3. **Вывод с использованием функции `puts`**. Для вывода строк можно использовать функцию `puts`. В отличие от `printf`, в конце строки автоматически ставится символ переноса строки.


.. code-block:: c
        
        char string[] = "Yet another string";
        puts(string);

Упражнение №1
-------------

Считать с клавиатуры строку и вывести ее на экран.

Работа со строками
==================

Работа со строками аналогична работе работе с массивами других типов. Получить доступ к i-му элементу строки можно одним из следующих образов:

.. code-block:: c
        
        char string[] = "Sample string";
        int i = 5;
        
        printf("%c", *(string + i));  // %c - single character
        printf("%c", string[i]);  // similar to other arrays

Пример 1
--------

Вычисление длины строки

.. code-block:: c
        
        int string_length(char * string){
            char * curr;
            for(curr = string; *curr != "\0"; ++curr);
            return curr - string;
        }

Пример 2
--------

Разворот строки. Необходимо помнить, что в конце строки должен остаться терминирующий нуль.

.. code-block:: c
        
        void reverse_string(char * string){
            int length;
            for (length = 0; string[length] != '\0'; ++length);
            for (int i = 0; i*2 < length-1; ++i) {
                string[i] ^= string[length-1-i];
                string[length-1-i] ^= string[i];
                string[i] ^= string[length-1-i];
            }
        }

Упражнение №2
-------------

* Считать с клавиатуры строку и вывести на экран коды всех её символов.
* Ввести строку с русскими буквами и посмотреть, сколько символов она будет занимать.


Упражнение №3
-------------

Измените функцию из примера 2 таким образом, чтобы изменялся произвольный кусок строки. В аргумент функции передаются начало и конец куска строки, который необходимо развернуть. Обратите внимание, что указанные границы могут выходить за границы строки, в этом случае надо развернуть строку от начала, если левая граница меньше нуля или до конца, если правая граница больше длины строки. Не забудьте про терминирующий нуль в конце!

Упражнение №4
-------------

Напишите программу, которая разворачивает каждое слово в строке. Слова отделены друг от друга пробелами. Символы, не являющиеся, буквами латинского алфавита разворачивать также не нужно.

Упражнение №5
-------------

Напишите функцию :c:`int is_polindrome(char * str)`, которая выводит 1, если строка является палиндромом и 0 если не является.

Упражнение №6
-------------

Напишите функцию :c:`char * ceasar(char * src, int shift)`, которая возвращает копию строки `src`, зашифрованную шифром Цезаря (код символа каждой английской буквы увеличивается на n).

Библиотека `string.h`
=====================

Для работы со строками в языке C применяется библиотека `string.h`. Она содержит набор функций, упрощающих работу со строками. Разберем основные функции, которые содержатся в данной библиотеке.

1. :c:`size_t strlen(const char *)` — Возвращает длину строки. 

2. :c:`char * strcat(char * str1, char * str2)` — Дописать строку `str2` в конец строки `str1`.

2.1. :c:`char * strncat(char * str1, char * str2, size_t n)` — Дописать первые `n` символов строки `str2` в конец строки `str1`.

3. :c:`int strcmp(char * str1, char * str2)` — Лексикографическое сравнение двух строк. Возвращает 0, если строки равны друг другу.

3.1. :c:`int strncmp(char * str1, char * str2, size_t n)` — Лексикографическое сравнение первых n символовдвух строк. Возвращает 0, если строки равны друг другу.

4. :c:`char * strcpy(char * dest, char * src)` — Копирует строку `src` по адресу `dest`.

4.1. :c:`char * strncpy(char * dest, char * src, size_t n)` — Копирует первые n байт строки `src` по адресу `dest`.

5. :c:`char * strstr(char * src, char * pattern)` — Находит первое вхождение подстроки `pattern` в строку `src`.

Упражнение №7
------------

На вход вашей программе подаются `n` (вводится с клавиатуры) контактов из телефонной книги вида `Thomas Anderson (987)123-45-67`. Напечатать отсортированный телефонный справочник.

Упражнение №8
-------------

Написать функцию :c:`void replace(char * src, char * pattern, char * dest)`, которая заменяет все вхождение **слова** `pattern` на слово `dest`. Если `pattern` входит в состав другого слова, заменять не требуется.

