Работа с сокетами.
###############################

:date: 2019-02-01 17:00
:summary: Работа с сокетами
:status: published 
:published: yes

.. default-role:: code

.. contents:: Содержание


.. role:: python(code)
   :language: python


Сетевые модели
===============

Сетевая модель OSI
-------------------

`Эталонная модель взаимодействия открытых систем`__ описывает уровни сетевого взаимодействия между компьютерами. Данная модель подразумевает семь уровней взаимодействия.

.. __: https://ru.wikipedia.org/wiki/Сетевая_модель_OSI


    7. Прикладной

    6. Представления

    5. Сеансовый

    4. Транспортный

    3. Сетевой

    2. Канальный

    1. Физический


Самый низкий уровень взаимодействия — передача информации (битов) между устройствами через сетевые кабеля, радиоканал и пр.

Канальный уровень — подразумевает работу с кадрами (frame) обеспечивая взаимодействие на физическом уровне и контроль ошибок. Именно к этому уровню относяться Ethernet, PPPoE и прочие. К этому уровню также относят драйвер сетевой карты, фактически обеспечивающий взаимодействие канального уровня с сетевым.

Сетевой уровень предназначен для определения пути передачи данных. Отвечает за трансляцию логических адресов и имён в физические, определение кратчайших маршрутов, коммутацию и маршрутизацию, отслеживание неполадок и «заторов» в сети. К этому уровню относяться такие протоколы, как IP, RIP и пр.

Транспортный уровень модели предназначен для обеспечения надёжной передачи данных от отправителя к получателю. К данному уровню относятся протоколы как TCP, UDP.

Сеансовый уровень модели обеспечивает поддержание сеанса связи, позволяя приложениям взаимодействовать между собой длительное время. Уровень управляет созданием/завершением сеанса, обменом информацией, синхронизацией задач, определением права на передачу данных и поддержанием сеанса в периоды неактивности приложений. Сюда относяться протоколы PPTP, SOCKS и пр.

Уровень представления обеспечивает преобразование протоколов и кодирование/декодирование данных. Запросы приложений, полученные с прикладного уровня, на уровне представления преобразуются в формат для передачи по сети, а полученные из сети данные преобразуются в формат приложений. На этом уровне может осуществляться сжатие/распаковка или шифрование/дешифрование, а также перенаправление запросов другому сетевому ресурсу, если они не могут быть обработаны локально.

Прикладной уровень — верхний уровень модели, обеспечивающий взаимодействие пользовательских приложений с сетью. К этому уровню относяться такие протоколы, как HTTP, FTP и пр.

Данная выше модель — эталонная. Реальная же модель, на которой работает современный интернет - `стек протоколов TCP/IP`__

.. __: https://ru.wikipedia.org/wiki/TCP/IP

Cтек протоколов TCP/IP
-----------------------

Модель OSI являеться эталонной, в то время, как реально в сетях применяеться TCP/IP, который выглядит следующим образом:

* Прикладной уровень (Application Layer) `HTTP`;
* Транспортный уровень (Transport Layer) `TCP`;
* Межсетевой уровень (Сетевой уровень) (Internet Layer) `IP`;
* Канальный уровень (Network Access Layer) `Ethernet`.
* + Физический (непосредственно не относится к TCP/IP)

Программный интерфейс сокет
============================

Сокет — программный интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет — абстрактный объект, представляющий конечную точку соединения.

Сокеты бывают клиентские и серверные. Клиентские можно сравнить с конечными аппаратами телефонной сети, а серверные — с коммутаторами. Клиентское приложение (например, браузер) использует только клиентские сокеты, а серверное (например, веб-сервер, которому браузер посылает запросы) — как клиентские, так и серверные сокеты.

Программный интерфейс сокетов в той или иной мере поддерживается всеми современными операционными системами.

Для взаимодействия между машинами с помощью стека протоколов TCP/IP используются адреса и порты. Адрес представляет собой 32-битную структуру для протокола IPv4, 128-битную для IPv6. Номер порта — целое число в диапазоне от 0 до 65535 (для протокола TCP).

Эта пара определяет сокет («гнездо», соответствующее адресу и порту).

В процессе обмена, как правило, используется два сокета — сокет отправителя и сокет получателя. Например, при обращении к серверу на HTTP-порт сокет будет выглядеть так: 194.106.118.30:80, а ответ будет поступать на mmm.nnn.ppp.qqq: xxxxx.

Каждый процесс может создать «слушающий» сокет (серверный сокет) и привязать его к какому-нибудь порту операционной системы (в UNIX непривилегированные процессы не могут использовать порты меньше 1024).

Слушающий процесс обычно находится в цикле ожидания, то есть просыпается при появлении нового соединения. При этом сохраняется возможность проверить наличие соединений на данный момент, установить тайм-аут для операции и т. д.

Каждый сокет имеет свой адрес. ОС семейства UNIX могут поддерживать много типов адресов, но обязательными являются INET-адрес и UNIX-адрес. Если привязать сокет к UNIX-адресу, то будет создан специальный файл (файл сокета) по заданному пути, через который смогут сообщаться любые локальные процессы путём чтения/записи из него. Сокеты типа INET доступны из сети и требуют выделения номера порта.

Обычно клиент явно «подсоединяется» к слушателю, после чего любое чтение или запись через его файловый дескриптор будут передавать данные между ним и сервером.

Клиент на socket
=================

Для работы с сокетами необходимо:

#. Подключить ``socket``;
#. Создать сокет
#. Присоединиться к серверу (для этого необходимо знать адрес сервера и номер порта, к которому Вы присоединяетесь)
#. Отправить сообщение. Сообщение должно быть битовым: можно получить из строки при помощи метода `encode`
#. Получить ответ


.. code-block:: python

    import socket                            # Подключаем

    sock = socket.socket()                   # Создаём
    sock.connect("<address>", "<port>")      # Присоединяемся

    sock.send("some text data".encode())     # Отправка
    data = sock.recv(<data length in bytes>) # Ответ
    data = data.decode("utf8")               # раскодируем сообщение в строку

Задача №1
==========
  Напишите программу, которая отправит на сервер имя и номер группы студента, и получит в качестве ответа условие следующей задачи (условие задачи заканчивается символом 0).

  Сервер - 10.55.169.100 (работает из локальной сети). Порт - 9000.
