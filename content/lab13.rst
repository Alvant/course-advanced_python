Паттерны проектирования. Декоратор и наблюдатель.
#################################################

:date: 2018-11-19 18:00
:summary: Паттерны проектирования. Декоратор и наблюдатель.
:status: published
:published: no

.. default-role:: code

.. contents:: Содержание


.. table_of_contest

Паттерны проектирования
=======================

При проектировании больших приложений, очень удобно использовать уже существующие паттерны проектирования, а не изобретать каждый раз велосипед.

Паттерн (шаблон) проектирования (от англ. design pattern) — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Как и где применять паттерн — целиком и полностью Ваша ответственность. В данном уроке мы познакомимся с некоторыми из них. Стоит отметить, что паттерны проектирования пришли в программирование из архитектуры, где они не получили широкого распространения. Все паттерны делятся на несколько групп:

#. Основные шаблоны
#. Порождающие шаблоны — шаблоны, абстрагирующие процесс инстанцирования.
#. Структурные шаблоны — определяют различные сложные структуры, изменяющие интерфейс существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.
#. Поведенческие шаблоны — определяют взаимодействие между объектами, увеличивая их гибкость.

Паттерн Decorator
=================

Проблема
-----------------
Паттерн Декоратор (Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту.

Описание взято с https://refactoring.guru/ru/design-patterns/decorator

Представьте, что вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях.

Основой библиотеки является класс Notificator с методом send, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/problem1-ru.png
   :width: 560
   :align: center

В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в Slack.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/problem2.png
   :width: 480
   :align: center


Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса Notificator. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?

Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/problem3.png
   :width: 630
   :align: center

Итак, нужен какой-то другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.

Решение
-----------------

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.

- Он статичен. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс.
- Он не разрешает наследовать поведение нескольких классов одновременно. Из-за этого вам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.

Одним из способов обойти эти проблемы является механизм композиции. Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн Декоратор.

Декоратор имеет альтернативное название — обёртка (вспоминте, как вы "оборачивали" функции в прошлых работах). Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

В примере с оповещениями мы оставим в базовом классе простую отправку по электронной почте, а расширенные способы отправки сделаем декораторами.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/solution2.png
   :width: 640
   :align: center

Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения.

Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время. Для остального клиентского кода, по сути, ничего не изменится, ведь все обёртки имеют точно такой же интерфейс, что и базовый класс оповещений.

Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов и так далее. К тому же клиент может «дообернуть» объект любыми другими обёртками, когда ему захочется.

Пример
-----------------
Рассмотрете пример из `файла`__. Он содержит простой пример реалзиации декоратора на питоне.

.. __: {filename}/code/lab13/decorator.ipynb

Задание
-----------------
Выполните задание из следующей работы.


Паттерн Observer 
=================

Паттерн Наблюдатель (Observer) — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

Проблема
-----------------

Представьте, что вы имеете два объекта: Покупатель и Магазин. В магазин вот-вот должны завезти новый товар, который интересен покупателю.

Покупатель может каждый день ходить в магазин, чтобы проверить наличие товара. Но при этом он будет злиться, без толку тратя своё драгоценное время.

.. image:: https://refactoring.guru/images/patterns/content/observer/observer-comic-1.png
   :width: 600
   :align: center

С другой стороны, магазин может разослать спам каждому своему покупателю. Многих это расстроит, так как товар специфический, и не всем он нужен.

Получается конфликт: либо покупатель тратит время на периодические проверки, либо магазин тратит ресурсы на бесполезные оповещения.

Решение
-----------------

Давайте называть Издателями те объекты, которые содержат важное или интересное для других состояние. Остальные объекты, которые хотят отслеживать изменения этого состояния, назовём Подписчиками.

Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не должен вести список подписки самостоятельно. Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.

.. image:: https://refactoring.guru/images/patterns/diagrams/observer/solution1-ru.png
   :width: 470
   :align: center

Теперь самое интересное. Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков.

Издателю безразлично, какой класс будет иметь тот или иной подписчик, так как все они должны следовать общему интерфейсу и иметь единый метод оповещения.

.. image:: https://refactoring.guru/images/patterns/diagrams/observer/solution2-ru.png
   :width: 460
   :align: center

Увидев, как складно всё работает, вы можете выделить общий интерфейс, описывающий методы подписки и отписки, и для всех издателей. После этого подписчики смогут работать с разными типами издателей, а также получать оповещения от них через один и тот же метод.

Пример
-----------------
Рассмотрете пример из `файла`__. Он содержит простой пример реалзиации декоратора на питоне.

.. __: {filename}/code/lab13/Observer.ipynb

Задание
-----------------
Выполните задание из следующей работы.