Паттерны проектирования. Декоратор и наблюдатель.
#################################################

:date: 2018-11-19 18:00
:summary: Паттерны проектирования. Декоратор и наблюдатель.
:status: published
:published: no

.. default-role:: code

.. contents:: Содержание


.. table_of_contest

Паттерны проектирования
=======================

При проектировании больших приложений, очень удобно использовать уже существующие паттерны проектирования, а не изобретать каждый раз велосипед.

Паттерн (шаблон) проектирования (от англ. design pattern) — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Как и где применять паттерн — целиком и полностью Ваша ответственность. В данном уроке мы познакомимся с некоторыми из них. Стоит отметить, что паттерны проектирования пришли в программирование из архитектуры, где они не получили широкого распространения. Все паттерны делятся на несколько групп:

#. Основные шаблоны
#. Порождающие шаблоны — шаблоны, абстрагирующие процесс инстанцирования.
#. Структурные шаблоны — определяют различные сложные структуры, изменяющие интерфейс существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.
#. Поведенческие шаблоны — определяют взаимодействие между объектами, увеличивая их гибкость.

Паттерн Decorator
-----------------

Проблема
-----------------
Паттерн Декоратор (Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту.

Описание взято с https://refactoring.guru/ru/design-patterns/decorator

Представьте, что вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях.

Основой библиотеки является класс Notificator с методом send, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/problem1-ru.png
   :width: 560
   :align: center

В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в Slack.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/problem2.png
   :width: 480
   :align: center


Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса Notificator. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?

Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/problem3.png
   :width: 630
   :align: center

Итак, нужен какой-то другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.

Решение
-----------------

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.

- Он статичен. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс.
- Он не разрешает наследовать поведение нескольких классов одновременно. Из-за этого вам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.

Одним из способов обойти эти проблемы является механизм композиции. Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн Декоратор.

Декоратор имеет альтернативное название — обёртка (вспоминте, как вы "оборачивали" функции в прошлых работах). Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

В примере с оповещениями мы оставим в базовом классе простую отправку по электронной почте, а расширенные способы отправки сделаем декораторами.

.. image:: https://refactoring.guru/images/patterns/diagrams/decorator/solution2.png
   :width: 640
   :align: center

Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения.

Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время. Для остального клиентского кода, по сути, ничего не изменится, ведь все обёртки имеют точно такой же интерфейс, что и базовый класс оповещений.

Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов и так далее. К тому же клиент может «дообернуть» объект любыми другими обёртками, когда ему захочется.

Пример
-----------------
Рассмотрете пример из `файла`__. Он содержит простой пример реалзиации декоратора на питоне.

.. __: {filename}/code/lab13/decorator.ipynb