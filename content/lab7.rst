Файловые дескрипторы. Чтение и запись в файл
############################################

:date: 2018-10-13 10:00
:summary: Файловые дескрипторы. Чтение и запись в файл
:status: draft
:published: yes

.. default-role:: code

.. contents:: Содержание

.. role:: c(code)
   :language: c

Файловые дескрипторы
====================

В операционной системе UNIX весь ввод и вывод осуществляется посредством чтения файлов или их записи, потому что все периферийные устройства, включая даже терминал пользователя, являются файлами определенной файловой системы. Это означает, что один однородный интерфейс управляет всеми связями между программой и периферийными устройствами.

В наиболее общем случае перед чтением из файла или записью в файл необходимо сообщить системе о вашем намерении; этот процесс называется "открытием" файла. Система выясняет, имеете ли вы право поступать таким образом (существует ли этот файл? имеется ли у вас разрешение на обращение к нему?), и если все в порядке, возвращает в программу небольшое положительное целое число, называемое дескриптором файла. Вся информация об открытом файле содержится в системе; программа пользователя обращается к файлу только через дескриптор файла. Дескрипторы файлов хранятся в таблице файловых дескрипторов, связанной с конкретным процессом (все дескрипторы в рамках одного процесса уникальны). Разные дескрипторы могут соответствовать одному и тому же файлу.

Для удобства выполнения обычных операций ввода и вывода с помощью терминала пользователя существуют специальные соглашения. Когда интерпретатор команд ("shell") прогоняет программу, он открывает три файла, называемые стандартным вводом (INPUT), стандартным выводом (OUTPUT) и стандартным выводом ошибок (STDERR), которые имеют соответственно числа 0, 1 и 2 в качестве дескрипторов этих файлов. В нормальном состоянии все они связаны с терминалом, так что если программа читает с дескриптором файла 0 и пишет с дескрипторами файлов 1 и 2, то она может осуществлять ввод и вывод с помощью терминала, не заботясь об открытии соответствующих файлов.

Пользователь программы может перенаправлять ввод и вывод на файлы, используя операции командного интерпретатора shell "<" и ">":

.. code-block:: c

    ./prog <infile >outfile 2>errfile

В этом случае интерпретатор shell изменит присваивание по умолчанию дескрипторов файлов 0, 1 и 2 с терминала на указанные файлы.


Низкоуровневый ввод/вывод - функции read и write
================================================

Ввод-вывод основан на системных вызовах read и write, к которым Си-программа обращается с помощью функций с именами read и write:

.. code-block:: c

    int n_read = read(int fd, char *buf, int n);
    int n_written = write(int fd, char *buf, int n);

Для обеих функций первым аргументом является дескриптор файла. Второй аргумент - указатель на память, куда читаются или откуда пишутся данные. Третий аргумент — это количество пересылаемых байтов.

Обе функции возвращают число переданных байтов. При чтении количество прочитанных байтов может оказаться меньше числа, указанного в третьем аргументе. Нуль означает конец файла, а -1 сигнализирует о какой-то ошибке. При записи функция возвращает количество записанных байтов, и если это число не совпадает с требуемым, следует считать, что запись не прошла.

За один вызов можно прочитать или записать любое число байтов.
Эффективнее обмениваться большим числом байтов, поскольку при этом требуется меньше системных вызовов.

Для демонстраии работы с read/write и дескрипторами, напишем программу, копирующую свой ввод на свой вывод:

Пример №1
---------

.. code-block:: c

    #include <unistd.h>

    int main() {
        const size_t size = 128;
        char buffer[size];
        int n;

        while ((n = read(0, buffer, size)) > 0) {
            write(1, buffer, n);
        }

        return 0;
    }

Также, рассмотрим использование read при написании программ более высокого уровня — типа getchar:

Пример №2
---------

.. code-block:: c

    // небуферизированный вариант
    int getchar(void) {
        char c;
        return (read(0, &c, 1) == 1) ? (unsigned char) c : EOF;
    }

EOF (End of file) - индикатор операционной системы, означающий, что данные в источнике закончились.

Примечание: для указания терминалу в UNIX и Linux «EOF» следует воспользоваться комбинацией клавиш Ctrl+D. В Windows — Ctrl+Z.

В примере №3 показан буферизованный вариант этой же функции.

Пример №3
---------

.. code-block:: c

    // с буферизацией
    int getchar(void) {
        const size_t size = 256;

        static char buf[size];
        static char *bufp = buf;
        static int n = 0;

        if (n == 0) { // буфер пуст
            n = read(0, buf, sizeof(buf)); // вспомним, что 0 - STDIN
            bufp = buf;
        }

        return (--n >= 0) ? (unsigned char) *bufp++ EOF;
    }

'static' переменная означает, что значение переменной сохраняется между вызовами функциями. То есть, при повторном вызове функции getchar, buf уже будет проинициализирован и в нем будут содержаться символы, введенные ранее.


Функции open, creat, close, unlink
==================================

В отличие от стандартных файлов ввода, вывода и ошибок, которые открыты по умолчанию, остальные файлы нужно открывать явно. Для этого есть два системных вызова: open и creat.

open открывает (или создает) файл для чтения или записи:

.. code-block:: c

    #include <fcntl.h>

    int fd;
    // int open(char *name, int flags, int mode);
    fd = open(name, flags, mode);

1 аргумент - имя открываемого/создаваемого файла.
2 аргумент специфицирует, каким образом должен быть открыт файл:
========        ======================================================
O_RDONLY        open for reading only
O_WRONLY        open for writing only
O_RDWR          open for reading and writing
O_NONBLOCK      do not block on open or for data to become available
O_APPEND        append on each write
O_CREAT         create file if it does not exist
O_TRUNC         truncate size to 0
O_EXCL          error if O_CREAT and the file exists
O_SHLOCK        atomically obtain a shared lock
O_EXLOCK        atomically obtain an exclusive lock
O_NOFOLLOW      do not follow symlinks
O_SYMLINK       allow open of symlinks
O_EVTONLY       descriptor requested for event notifications only
O_CLOEXEC       mark as close-on-exec
========        ======================================================

3 аргумент mode - права доступа:
=======   ============================
S_IRUSR   чтения для владельца
S_IWUSR   запись для владельца
S_IXUSR   исполнение для владельца
S_IRGRP   чтение для группы
S_IWGRP   запись для группы
S_IXGRP   исполнение для группы
S_IROTH   чтения для остальных
S_IWOTH   запись для остальных
S_IXOTH   исполнение для остальных
=======   ============================

Для flags и mode можно использовать побитовое OR для сложения модификаторов: O_RDWR | O_CREAT.

Функция возвращает дескриптор файла (>= 0 - согласно документации), и -1, при неудаче.

Чтобы открыть существующий файл только на чтение, можно написать:

.. code-block:: c

    int fd = open(name, O_RDONLY, 0);

Создание нового файла или перезапись старого обеспечивает системный вызов creat:

.. code-block:: c

    // int creat(char *name, int mode);
    int fd = creat(name, mode);

Функция creat возвращает дескриптор файла, если файл создан, и -1, если по каким-либо причинам файл создать не удалось. Если файл уже существует. creat «обрежет» его до нулевой длины, что равносильно выбрасыванию предыдущего содержимого данного файла; создание уже существующего файла не является ошибкой.

Если строится новый файл, то creat его создаст с правами доступа, специфицированными в аргументе mode. В системе UNIX с каждым файлом ассоциированы девять бит, содержащие информацию о правах пользоваться этим файлом для чтения, записи и исполнения лицам трех категорий: собственнику файла, определенной им группе лиц, и всем остальным. Таким образом, права доступа удобно специфицировать с помощью трех восьмеричных цифр. Например, 0755 специфицирует чтение, запись и право исполнения собственнику файла, а также чтение и право исполнения группе и всем остальным.

Напишем упрощенную версию программы cp (cp trg src) - копирование файла:

Пример №4
---------

.. code-block:: c

    #include <unistd.h>
    #include <stdio.h> // perror
    #include <fcntl.h>

    int main(int argc, char *argv[]) {
        int f1, f2, n;
        const size_t size = 512;
        char buf[size];
        int f2_perms = 0666; // RW rights

        if (argc != 3) {
            perror("Example: ./cp src_file trg_file");
            return -1;
        }
        if ((f1 = open(argv[1], O_RDONLY, 0)) == -1) {
            perror("Can't open src_file");
            return -1;
        }
        if ((f2 = creat(argv[2], f2_perms)) == -1) {
            close(f1);
            perror("Can't create trg_file");
            return -2;
        }
        while ((n = read(f1, buf, size)) > 0) {
            if (write(f2, buf, n) != n) {
                close(f1);
                close(f2);
                perror("Error when cp src_file trg_file");
                return -3;
            }
        }
        close(f1); // закрывает открытый дескриптор
        close(f2); // возвращает 0 — при успешном закрытии, и значение меньше 0 — при ошибке
        return 0;
    }

Функция perror пишет сообщение в STDERR. Данная программа создает файл вывода с фиксированными правами доступа, определяемыми кодом 0666. С помощью утилиты stat мы можем проверить права файла.

Имеется ограничение на количество одновременно открытых в программе файлов. Любая программа, которая намеревается работать с большим количеством файлов, должна быть готова повторно использовать их дескрипторы.

Упражнение №1
-------------

Узнать допустимое количество одновременно открытых в программе файлов, написав си код.

На самом деле, узнать максимальное количество открытых файлов можно с помощью команды ulimit:

.. code-block:: c
    ulimit -n

Функция close(int fd) разрывает связь между файловым дескриптором и открытым файлом и освобождает дескриптор для его применения с другим файлом. Завершение программы при помощи exit или return в главной программе закрывает все открытые файлы.

Упражнение №2
-------------

Напишите программу cat (использовать функции: read, write, open, close). Например, функция 'cat x.c y.c' направит в стандартный вывод содержимое файлов x.c и y.c


Случайный доступ (lseek)
========================

Ввод-вывод обычно бывает последовательным, т.е. каждая новая операция чтения-записи обрабатывает позицию файла, следующую за обработанной в предыдущей операции (чтения-записи). При желании, файл можно читать в произвольном порядке. Системный вызов lseek предоставляет способ передвигаться по файлу, не читая и не записывая данные. Так, функция с прототипом

.. code-block:: c

    long lseek(int fd, long offset, int origin);

в файле с дескриптором fd устанавливает текущую позицию, смещая ее на величину offset относительно места, задаваемого значением origin. Значения параметра origin 0 (SEEK_SET), 1 (SEEK_CUR) или 2 (SEEK_END) означают, что на величину offset отступают соответственно от начала, текущей позиции или конца файла:

Пример №5
---------

.. code-block:: c

    // чтение n байт c позиции pos
    int get(int fd, long pos, char *buf, int n) {
        if (lseek(fd, pos, 0) >= 0) { // установка позиции
            return read(fd, buf, n);
        } else {
            return -1;
        }
    }

lseek может быть полезна и в других сценариях:

.. code-block:: c

    int pos = lseek(file, 0, SEEK_CUR); // определение текущей позиции в файле
    int size = lseek(file, 0, SEEK_END); // определение размера файла


Функции pread/pwrite
====================

.. code-block:: c

    ssize_t pread(int fd, void *buff, size_t count, off_t offset);
    ssize_t pwrite(int fd, const void *buff, size_t count, off_t offset);

Функция pread считывает из файла, с дескриптором fd, смещением offset, количество байт count в буфер buff. Функция pwrite работает аналогично, но для записи.


Изменение прав файла
====================

.. code-block:: c

    int chmod(const char *path, mode_t mode);
    int fchmod(int fildes, mode_t mode);

Как видно из определения, функция chmod изменяет права файла по его пути, а функция fchmod — по его файловому дескриптору. В случае успешного изменения прав, возвращают 0, в случае ошибки -1. Для параметра mode определены макросы, описанные выше вместе с функцией open.

Пример №6
---------

.. code-block:: c

    #include <stdio.h>
    #include <fcntl.h>
    #include <string.h>
     
    int main(int argc, char *argv[]) {
        // Изменить права для файла 1.txt по его пути
        chmod("1.txt", S_IRUSR | S_IWUSR | S_IXUSR);
        // Изменить права для файла 2.txt по его пути
        int file = open("2.txt", O_RDWR);
        close(file);
    }


Удаление файлов
===============

Удаление файла.

.. code-block:: c

    int remove(const char* filename);

Возвращает 0 — в случае успеха, и -1 в случае ошибки.

Функция unlink(char *name) удаляет имя из файловой системы и уменьшение счетчика ссылок на файл на 1. При достижении счетчика 0 файл удаляется из системы.

Если аргумент - имя файла, то функции remove, unlink отрабатывают одинакого. unlink является Posix функцией, хоть и есть на Windows.


fopen / fclose / fprintf / fscanf
=================================

Существует еще один способ работы с файлами через структуру FILE, определенную в <stdio.h>.

.. code-block:: c

    FILE *fopen (const char *filename, const char *mode);
    int fclose(FILE *fp);
    int fprintf(FILE *fp, const char *format, …);
    int fscanf(FILE *fp, const char *format, …);

.. code-block:: c

    FILE *f = fopen("file1.txt", "r");

fopen -- функция из стандартной библиотеки. Первый параметр -- имя файла (в текущем каталоге). Второй параметр задает режим открытия файла; в данном случае "r" означает, что файл будет открыт только для чтения. 
Возможные modes: r, w, a, r+, w+, a+.
Эта функция возвращает ненулевой указатель, если открытие прошло успешно и возвращает NULL, если произошла ошибка. Ошибка может возникать в следующих ситуациях:
1) не существует файла
2) у программы недостаточно прав доступа для работы с файлом

Считывание файла:

.. code-block:: c

    fscanf(f, "%s", ptr);

Эта функция работает аналогично функции scanf.

Если мы хотим записать в файл что-то, то мы должны сначала открыть его на запись:

.. code-block:: c

    FILE *f = fopen("file2.html", "w"); // открыть на дозапись - "а", append

Затем можно использовать функцию fprintf(f, ...);

Закрытие файла: fclose(f);

Зачем использовать fclose? Запись производится в буфер (не сразу на диск). Только тогда, когда буфер будет заполнен до конца, он будет сразу весь записан на жесткий диск (данные могут не сохраниться на диске при fprintf). Помнить: **буферизация**!

fflush(f) - "проталкивает" буфер в файл.

Стандартные константы:

.. code-block:: c
    FILE *stdin
    FILE *stdout
    FILE *stderr

Так как интерфейс за обращением к вводу/выводу тот же, что и при записи в файл, то этим можно воспользоваться при написании программы для работы с файлами. Например, для отладки программы можно выводить информацию на экран монитора, а не в файл.

Еще о модификаторах:

.. code-block:: c

fopen("file1.txt", "wt"); // откроет файл как текстовый файл, 't' можно опустить
fopen("file1.txt", "wb"); // откроет файл как бинарный файл

Стоит упомянуть аналог функции gets для работы с файлами:

.. code-block:: c

    char *fgets(char *buffer, size_t length, FILE *file);

buffer - это указатель на буфер, в который мы читаем;
length - это размер буфера;
file - это файл, из которого мы читаем (если читаем с клавиатуры, то разумно использовать stdin).
Функция возвращает строку.


fread и fwrite
==============

Не все файлы выглядят как текст. В файле могут быть записаны числовые данные и мы можем их считать вызовом одной функцией fread:

.. code-block:: c

    size_t fread(void *ptr, size_t size, size_t nelts, FILE *f);

void *ptr -- указатель на ту область памяти, в которую мы читаем
size_t size -- размер элемента, который мы читаем
size_t nelts -- максимальное количество элементов, которые можно записать
FILE *f -- файл, из которого читаем
size_t fread() -- сама функция возвращает количество элементов, которые удалось прочитать

Есть парная функция:

size_t fwrite(const void *ptr, size_t size, size_t nelts, FILE *F);

Аналогично fread эта функция возвращает количество элементов, которые удалось записать.
Тут параметр nelts просто показывает, сколько элементов надо вывести.

Пример №7
---------

.. code-block:: c

#include <stdio.h>

    int main() {
        FILE *fp = fopen("tmp_file.bin", "w");
        int elems[] = {0, 1, 2, 3};
        int rc = fwrite(elems, sizeof(int), 4, fp);
        fclose(fp);

        int elems_out[4];
        fp = fopen("tmp_file.bin", "r");
        rc = fread(elems_out, sizeof(int), 4, fp);

        for (int i = 0; i < 4; ++i) {
           printf("%d ", elems_out[i]);
        }
        printf("\n");
        fclose(fp);
        return 0;
    }


fseek и ftell
=============

Чтобы переместиться на нужную позицию в файле используется функция fseek:

.. code-block:: c
    int fseek(FILE *f, long offset, int flag);

FILE *f - файл, в котором передвигаемся
long offset - количество байтов для отступа, отступ производится в соответствии с 3-м параметром
int flag - позиция, от которой будет совершен отступ. в стандартной библиотеке C для этого параметра определены 3 константы:

SEEK_SET - начало файла
SEEK_CUR - текущас позиция
SEEK_END - конец файла

Функция возвращает ноль, если операция прошло успешно, иначе возвращается ненулевое значение.

Еще одна полезная функция может определить текущее положение в файле:

.. code-block:: c
    long int ftell(FILE *f);


fgets и fputs
=============

.. code-block:: c
    char *fgets(char *line, int maxline, FILE *fp)
    int fputs(char *line, FILE *fp)

Функция fgets читает следующую строку ввода (включая и символ новой строки) из файла fp в массив line, причем она может прочитать не более maxline-1 символов. Переписанная строка дополняется '\0'. Обычно fgets возвращает line, а по исчерпании файла или в случае ошибки NULL.

Функция вывода fputs пишет строку в файл. Функция возвращает EOF, если возникла ошибка, и нуль в противном случае.


Использование fopen вместо open
===============================

Для работы с файлами у нас есть несколько механизмов. open является низкоуровневой функцией, взаимодействующей с ОС, тогда как fopen определен в stdio.h и предоставляет более богатое поведение. Перечислим несколько пунктов, когда стоит использовать fopen вместо open:

1) fopen предоставляет вам буферизацию ввода-вывода, которая может оказаться намного быстрее, чем то, что вы делаете с помощью open
2) fopen выполняет перевод строки, если файл не открывается в двоичном режиме, что может быть очень полезно, если ваша программа когда-либо портирована в среду, отличную от Unix
3) FILE* дает вам возможность использовать fscanf и другие функции stdio
4) Ваш код может когда-нибудь быть перенесен на другую платформу, которая поддерживает только ANSI C и не поддерживает функцию open


Memory mapping
==============

.. code-block:: c

    void * mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
    int munmap(void *start, size_t length);

Функция mmap отражает length байтов, начиная со смещения offset файла, определенного файловым дескриптором fd, в память, начиная с адреса start. Местоположение отраженных данных возвращается самой функцией mmap.

Рассмотрим следующий пример. Программа открывает файл, создавая его, если он прежде не существовал. Третий параметр указывает режим доступа для чтения и записи. Поскольку мы не знаем длину файла, мы используем lseek , чтобы гарантировать, что файл является достаточно большим, чтобы сохранить целое число . После чего возвращаемся к началу файла.

Программа отображает файл и затем закрывает дескриптор файла, потому что он больше не нужен. Программа пишет случайное целое число в отображаемую память, таким образоми в файл, и освобождает отображаемую память. Вызов munmap ненужен, потому что Linux автоматически освободил бы отображаемую память и файл, когда программа завершится.

Пример №8
---------

.. code-block:: c

    #include <stdlib.h>
    #include <stdio.h>
    #include <fcntl.h>
    #include <sys/mman.h>
    #include <sys/stat.h>
    #include <time.h>
    #include <unistd.h>

    // Возвратить случайное число из диапазона [low, high]
    int random_range (unsigned const low, unsigned const high) {
        unsigned const range = high - low + 1;
        return low + (int) (((double) range) * rand () / (RAND_MAX + 1.0));
    }

    int main (int argc, char* const argv[]) {
        const size_t file_length = 256;

        // Инициализируем генератор случайных чисел
        srand(time(NULL));

        // Открываем (создаем) файл, достаточно большой, чтобы хранить целое число без знака
        int fd = open(argv[1], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
        lseek(fd, file_length+1, SEEK_SET);
        write(fd, "", 1);
        lseek(fd, 0, SEEK_SET);

        // Создаем отображение в памяти
        void* file_memory = mmap(0, file_length, PROT_WRITE, MAP_SHARED, fd, 0);
        close(fd);

        // Пишем случайное целое число в отображенную память
        sprintf((char*)file_memory, "%d\n", random_range(-100, 100));

        // Освобождаем память
        munmap(file_memory, FILE_LENGTH);
        // Закрываем fd
        close(fd);

        return 0;
    }


Работает эта функция так. Мы указываем этой функции файл на диске, и она "отображает" этот файл в некоторую область в памяти. В результате работы функции мы получаем указатель на начало файла. И потом мы можем работать с этим файлом как с обычным указателем на какую-то область памяти: можем "ходить" вперед и назад по этому файлу.

Можно "отобразить" не весь файл целиком, а, например, отдельную часть файла: с 3-его килобайта по 4-ый килобайт. 


Упражнения
==========

Упражнение №3
-------------

Напишите программу, выводящую количество строк, слов и букв (lower и upper) в файле.

Упражнение №4
-------------

Напишите программу, сравнивающую два файла и печатающую первую строку, в которой они различаются


Упражнение №5.1
---------------

Написать программу, которая будет **добавлять** новых студентов в базу в отсортированном по оценкам порядке.
Ввод: на первой строке N - количество новых учеников. На следующих N строках данные в виде: NAME MARK.
Имя имеет размер меньше 128 символов, оценка от 0 до 1000000.
Данные о студентах хранить в файле csv формата (в 1 строке - названия колонок: name, mark).
При добавлении новых студентов в файл, требуется их сортировка по оценкам - по убыванию.

Упражнение №5.2
---------------
Что изменится в 5.1, если будет стоять ограничение на оценку: от 0 до 10.
Исправить программу в соответствии с новым ограничением.


Упражнение №6
-------------
Реализовать ring buffer.


Дополнительные материалы
========================

1) https://www.opennet.ru/docs/RUS/zlp/005.html
2) https://ru.bmstu.wiki/Файловый_дескриптор
3) http://citforum.ru/programming/c_unix/gl_4_1.shtml
4) http://givi.olnd.ru/kr2/07.html (дополнительно содержит описание функций работы со строками, преобразование символов, математические функции)
5) http://givi.olnd.ru/kr2/08.html
6) http://www.cs.vsu.ru/~svv/ux2017/lecture%206.pdf (Объясняется таблица открытых файлов процесса)
7) https://ejudge.ru/study/3sem/sem10.pdf (Подробное описание функций для работы с файлом, директориями)
8) http://masters.donntu.org/2005/fvti/lukyanov/library/ipc/mmap.html (Про mmap)
9) https://fresh2refresh.com/c-programming/c-file-handling/fopen-fclose-gets-fputs-functions-c
