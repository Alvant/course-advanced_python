Повторение синтаксиса Python. ООП. Принципы и парадигмы ООП. Объекты и классы в Python.
#######################################################################################

:date: 2018-10-29 07:30
:summary: Повторение синтаксиса Python. ООП. Принципы и парадигмы ООП. Объекты и классы в Python.
:status: published
:published: yes

.. default-role:: code

.. contents:: Содержание

Повторение синтаксиса Python
============================

Операции с целыми числами
-------------------------

.. code-block:: python
        
        2 + 5
	10 - 5
	6 * 7
	12345678 * 987654328765432318765
	3 + 5 * 4
	(3 + 5) * 4
	40 // 8
	42 // 8
	42 % 8
	239 % 10
	239 // 10
	2 ** 5
	- (42)
	+ (42)
	+-+42

Сообщения об ошибках
--------------------

.. code-block:: python
	
	-*42
	
	print('test')
	* 23
	
	5 // 0

Числа с плавающей точкой
------------------------

.. code-block:: python

        0.5 + 0.3
	5 / 2
	5 // 2
	1 / 3
	0.3 + 0.3 + 0.3
	2 ** 5
	9 ** 0.5
	5e-1
	1234e2

Переменные
----------

.. code-block:: python

	a = 3
	a
	a += 4
	a
	a
	2 * a  # выводится только последнее значение и только при работе в интерактивном режиме!



Она сообщает компилятору о необходимости подключить файл `stdio.h`. Этот файл содержит информацию, необходимую для правильного выполнения функций библиотеки стандартного ввода/вывода языка C.

Вторая строка:

.. code-block:: c
        
        /* Пример простой программы */

является комментарием.
Комментарием в языке C является любая последовательность символов, заключенная между парами символов `/*` и `*/`.
Также, все символы, располагающиеся за парой символов `//` и до конца строки, рассматриваются как комментарий.

Строка

.. code-block:: c

        int main()

Определяет *тип* и имя *функции*. `int` означает, что функция после того как отработает должна вернуть целочисленный тип данных, а `main` - имя функции.

Всё дело в том, что все исполняемые операторы в программах на C и C++ не могут существовать сами по себе - они должны быть обязательно заключены в *функции*.

Функция `main()` - это *главная функция*, выполнение программы начинается с её вызова и заканчивается выходом из неё. Возвращаемое значение `int main()` в случае успешных вычислений должно быть равно 0, что означает "ошибка номер ноль", то есть "нет ошибки". В противном процесс, вызвавший программу, может посчитать её выполнившейся с ошибкой.
Все *тела* функций заключаются в парные фигурные скобки `{}`.

Строка

.. code-block:: c

        int year;

Объявляет переменную, называемую year, и сообщает компилятору, что эта переменная целая. В языке C все переменные должны быть объявлены прежде, чем они будут использованы. Процесс объявления переменных включает в себя определение имени (идентификатора) переменных (year) и указание типа переменных (int).

Строка

.. code-block:: c

        year=2018;

является оператором присваивания. В этой строке переменной с именем `year` присваивается значение 2018.

Также стоит отметить, что все операторы в языке C заканчиваются символом "точка с запятой".

Строка

.. code-block:: c

        printf("Hello, World! MIPT %d.\n", year);

является вызовом стандартной функции `printf()`, которая выводит на экран некоторую информацию. Эта строка состоит из двух частей: имени функции `printf()` и двух ее аргументов "Hello, World! MIPT %d.\n" и year, разделенных запятой.

Первый аргумент функции `pintf()` - это строка в кавычках "Hello, World! MIPT %d.\n", которую иногда называют *управляющей строкой*. Эта строка может содержать любые символы или *спецификации формата*, начинающиеся с символа `%`. Обычные символы просто отображаются на экране в том порядке, в котором они следуют.

Спецификация формата, начинающаяся с символа `%`, указывает формат, в котором будет выводиться значение переменной year, являющейся вторым аргументом функции `printf()`. Спецификация `%d` указывает, что будет выводиться целое число в десятичной записи. Комбинация символов `\n` сообщает функции `printf()` о необходимости перехода на новую строку(символ новой строки).

Чтобы выполнить программу, нужно её сохранить в текстовом файле `helloworld.c` и скомпилировать следующей командой:

.. code-block:: c

        $ gcc -o helloworld helloworld.c

Опция `-o` сообщает компилятору, что итоговый исполняемый файл должен называться `helloworld`. `gcc` - это компилятор языка C, входящий в состав проекта GCC (GNU Compiler Collection). 

Упражнение №1
-------------

Скомпилируйте и выполните данную программу.

Этапы сборки: препроцессинг, компиляция, компоновка
===================================================

Компиляция исходных текстов на C в исполняемый файл происходит в три этапа.

.. image:: /images/lab1/lab1_1.png

Препроцессинг
-------------

Эту операцию осуществляет текстовый препроцессор.

Исходный текст частично обрабатывается - производятся:

#. Замена комментариев пустыми строками
#. Текстовое включение файлов - `#include`
#. Макроподстановки - `#define`
#. Обработка директив условной компиляции - `#if`, `#ifdef`, `#elif`, `#else`, `#endif`

Компиляция
----------

Процесс компиляции состоит из следующих этапов:

#. **Лексический анализ**. Последовательность символов исходного кода файла преобразуется в последовательность лексем.
#. **Синтаксический анализ**. Последовательность лексем преобразуется в дерево разбора.
#. **Семантический анализ**. Дерево разбора обрабатывается с целью установления его семантики (смысла) - например, привязка идентификаторов к их декларациям, типам, проверка совместимости, определение типов выражений и т. д.
#. **Оптимизация**. Выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла.
#. **Генерация кода**. Изпромежуточного представления порождается объектный код.

Результатом компиляции является **объектный код**.

Объектный код - это программа на языке машинных кодов с частичным сохранением символьной информации, необходимой в процессе сборки.

При отладочной сборке возможно сохранение большого количества символьной информации (идентификаторов переменных, функций, а также типов).


Компоновка
----------

Компоновка также называется *связывание* или *линковка*. На этом этапе отдельные объектные файлы проекта соединяются в единый *исполняемый файл*.

На этом этапе возможны так называемые ошибки связывания: если функция была объявлена, но не определена, ошибка обнаружится только на этом этапе.

Упражнение №2
-------------

Выполнитев консоли для ранее созданного файла helloworld.c последовательно операции препроцессинга, компиляции и компоновки:

#. Препроцессинг:

.. code-block:: bash

        $ gcc -E -o helloworld1.c helloworld.c

#. Компиляция:

.. code-block:: bash

        $ gcc -c -o helloworld.o helloworld1.c

#. Компоновка:

.. code-block:: bash

        $ gcc -o helloworld helloworld.o

Принцип раздельной компиляции
=============================

Компиляция - алгоритмически сложный процесс, для больших программных проектов требующий существенного времени и вычислительных возможностей ЭВМ. Благодаря наличию в процессе сборки программы этапа компоновки (связывания) возникает возможность *раздельной компиляции*.

В модульном подходе программный код разбивается на несколько файлов `.c`, каждый из которых компилируется отдельно от остальных.

Это позволяет значительно уменьшить время перекомпиляции при имзенениях, вносимых лишь в небольшое количество исходных файлов. Также это даёт возможность замены отдельных компонентов конечного программного продукта, без необходимости пересборки всего проекта.

Типы данных
===========

Напишем программу, которая считает длину окржуности, и площадь круга по введённому значению радиуса:

.. code-block:: c

        #include <stdio.h>
        int main() {
                float radius, length, area;
                printf("Введите значение радиуса:\n");
                scanf("%f", &radius);
                length=3.1415 * 2 * radius;
                area=3.1415 * radius * radius;
                printf("Радиус=%f, длина окружности=%f, площадь круга=%f\n", radius, length, area);
                return 0;
                }

В этой программе тип переменной radius является float, соответственно также поменялись спецификаторы формата ввода и вывода переменной radius в функциях scanf() и printf().

Базовые типы данных:

#. **char**     - символьные,
#. **int**      - целые,
#. **float**    - с плавающей точкой,
#. **double**   - с плавающей точкой двойной длины,

Модификаторы типов данных:

#. **signed**   - знаковый,
#. **unsigned** - беззнаковый,
#. **long**     - длинный,
#. **short**    - короткий.

Все возможные типы данных с различными комбинациями модификаторов:

+--------------------+-------------------+------------------------------------+
|       Тип          | Размер в байтах   | Интервал изменения                 |
|                    | (битах)           |                                    |
+--------------------+-------------------+------------------------------------+
| char               | 1 (8)             | от -128              до 127        |
+--------------------+-------------------+------------------------------------+
| unsigned char      | 1 (8)             | от 0                 до 255        |
+--------------------+-------------------+------------------------------------+
| signed char        | 1 (8)             | от -128              до 127        |
+--------------------+-------------------+------------------------------------+
| int                | 2 (16)            | от -32768            до 32767      |
+--------------------+-------------------+------------------------------------+
| unsigned int       | 2 (16)            | от 0                 до 65535      |
+--------------------+-------------------+------------------------------------+
| signed int         | 2 (16)            | от -32768            до 32767      |
+--------------------+-------------------+------------------------------------+
| short int          | 2 (16)            | от -32768            до 32767      |
+--------------------+-------------------+------------------------------------+
| unsigned short int | 2 (16)            | от 0                 до 65535      |
+--------------------+-------------------+------------------------------------+
| signed short int   | 2 (16)            | от -32768            до 32767      |
+--------------------+-------------------+------------------------------------+
| long int           | 4 (32)            | от -2147483648       до 2147483647 |
+--------------------+-------------------+------------------------------------+
| signed long int    | 4 (32)            | от -2147483648       до 2147483647 |
+--------------------+-------------------+------------------------------------+
| unsigned long int  | 4 (32)            | от 0                 до 4294967295 |
+--------------------+-------------------+------------------------------------+
| float              | 4 (32)            | от 3.4E-38           до 3.4E 38    |
+--------------------+-------------------+------------------------------------+
| double             | 8 (64)            | от 1.7E-308          до 1.7E 308   |
+--------------------+-------------------+------------------------------------+
| long double        | 10 (80)           | от 3.4E-4932         до 3.4E 4932  |
+--------------------+-------------------+------------------------------------+

Основные команды формата (спецификаторы формата):

#. **%c** - символ,
#. **%d** - целое десятичное число,
#. **%i** - целое десятичное число,
#. **%e** - десятичное число в виде x.xx e+xx,
#. **%o** - восьмеричное число,
#. **%s** - строка символов,
#. **%x** - шестнадцатеричное число (5a5f),
#. **%p** - указатель,
#. **%n** - указатель в увеличенном формате.


Управляющие операторы
=====================

Управляющие операторы можно разбить на три категории:

#. **Условные операторы** if, if-else и switch.
#. **Операторы цикла** for, while и do-while.
#. **Операторы безусловного перехода** goto.


Условный оператор if и if-else
------------------------------

.. code-block:: c
        
        #include <stdio.h>
        int main() {
                int sgn;
                float x;
                printf("Введите число:");
                scanf("%f", &x);
                if (x > 0) {
                        sgn=1;
                        printf("Число %f положительное\n", x);
                        }
                else if (x < 0) {
                        sgn=-1;
                        printf("Число %f отрицательное\n", x);
                        }
                else {
                        sgn=0;
                        printf("Число %f равно нулю\n",x);
                        }
                return 0;
                }


Оператор switch
---------------

.. code-block:: c

        #include <stdio.h>
        int main() {
                char ch;
                printf("Введите заглавную букву русского алфавита:");
                ch=getchar();
                if (ch >= 'А' && ch <= 'Я'){
                        switch(ch) {
                                case 'А':
                                        printf("Аналит \n");
                                case 'Б':
                                        printf("Биология \n");
                                case 'В':
                                        printf("Вычматы \n");
                                case 'Г':
                                        printf("Генетика \n");
                                default:
                                        printf("Матан, теорвер и другие \n");
                                }
                       }
               else {
                printf("Надо было ввести заглавную русскую букву \n");
               }
               return 0;
               }


Оператор for
------------

.. code-block:: c

        #include <stdio.h>
        int main() {
                int i;
                for (i=10; i>0; i--) {
                        printf("%d\n", i);
                        }
                printf("Конец обратного отсчёта\n");
                return 0;
                }


Циклы while и do-while
----------------------

.. code-block:: c

        #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>
        int main() {
                int s, x;
                int n=0;
                randomize();
                s=random(100) + 1;
                do {
                        printf("Введите число от 1 до 100: ");
                        scanf("%d", &x);
                        n++;
                        if (s < x) {
                                printf("Загаданное число меньше\n");
                                }
                        if (s > x) {
                                printf("Загаданное число больше\n");
                                }
                        } while (s-x);
               printf("Вы угадали число !\n");
               printf("Затратили на угадывание %d попыток\n", n);
               return 0;
               }
