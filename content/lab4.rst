Массивы в С. Динамические массивы, malloc, realloc, free
#####################################################################

:date: 2018-09-21 10:00
:summary: Массивы в С. Динамические массивы, malloc, realloc, free
:status: draft
:published: yes

.. default-role:: code

.. contents:: Содержание


Одномерные массивы в **С**
==========================

Массив — это непрерывный участок памяти, содержащий последовательность элементов одинакового типа, обозначаемый одним именем.

.. code-block:: c

        // Синтаксис: type arrayName[arraySize];
        int numbers[6]; // объявление массива из 6 элементов типа int
        int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // массив a из 10 чисел типа int
        int b[10] = {1};
        char ch[]  = {'a', 'r', 'r', 'a', 'y'}; // массив из char
        char ch2[] = "array"; // так тоже возможно, но это не то же, что выше! '\0'
        
        // Обращение к элементам массива
        int a0 = a[0]; // индексирование с 0
        int b9 = b[9]; // b9 становится равным последнему элементу массива
        
        // Проверка выхода за границы не гарантируется!
        int elem = a[-1];
        elem = a[20];
        elem = a[10];

        // Количество элементов массива
        int an_array[] = {0, 1, 2, 3}
        int array_count = sizeof(an_array) / sizeof(int) // array_count = 4

В 1 случае мы лишь резервируем область памяти под массив без инициализации. В 3 случае происходит инициализация по следующему правилу - если количество инициализируемых элементов меньше размера массива, оставшиеся элементы равны 0. В данном случае первый элемент массива равен 1, остальные проинициализированы 0 (удобно использовать запись "int b[10] = {0}" для обнуления элементов массива).

При создании массива выделяется непрерывная последовательность байт под массив:

.. image:: https://i.imgur.com/FEjXcJr.png
   :width: 500
   :align: center

Представленный на рисунке массив содержит q элементов с индексами от 0 до q-1. Каждый элемент занимает в памяти компьютера k байт.

Пример работы с одномерным массивом (Записываем значения в массив с клавиатуры, а затем распечатываем их):

Пример №1
---------

.. code-block:: c

    #include <stdio.h>
    
    int main()
    {
        int a[5]; // объявлен массив a из 5 элементов
        // Ввод элементов массива
        for (int i = 0; i < 5; i++) 
        {
            printf("a[%d] = ", i);
            scanf("%d", &a[i]); // &a[i] - адрес i-го элемента массива
        }
        // Вывод элементов массива
        for (i = 0; i<5; i++)
        {
            printf("%d ", a[i]);
        }
        return 0;
    }

Упражнение №1
-------------

Напишите программу, которая создаст массив с первыми N = 20 числами Фибоначчи

Многомерные массивы
===================

В С существуют также и многомерные массивы:

.. code-block:: c

    // создание массива
    char two_d[3][5];
    
    // доступ к элементам
    char ch = two_d[2][4];
    
    // по аналогии с одномерным массивом можно проинициализировать 2-мерный
    // в такой записи мы могли бы опустить первую размерность (2), но обязаны указывать последние
    int two_d[2][3] = {{ 5, 2, 1 },
                       { 6, 7, 8 }}
    // или даже так:
    int two_d2[2][3] = {1, 2, 3, 4, 5, 6};

Для лучшего понимания последней записи, рассмотрим как многомерные массивы расположены в памяти:

.. code-block:: c

    int32_t a[2][3];


.. image:: https://i.imgur.com/b5CcEE8.png
   :width: 500
   :align: center

Общее количество элементов в приведенном двумерном массиве определится как
КоличествоСтрок * КоличествоСтолбцов = 2 * 3 = 6.
Количество байт памяти, требуемых для размещения массива, определится как
КоличествоЭлементов * РазмерЭлемента = 6 * 4 = 24 байта.

Упражнение №2
-------------

Напишите программу, перемножающую матрицы A(2x3), B(3x2).

Связь между массивами и указателями:

.. code-block:: c

    int a[] = {1, 2, 3};
    
    // обращение к 0 элементу:
    int a0 = a[0];
    a0 = *a;

    int k = 2;
    // обращение к k-ому элементу (две записи абсолютно эквивалентны):
    int ak = a[k];
    ak = *(a+k);

    // *(a+k) == *(k+a), а это значит, что язык позволяет писать даже так:
    ak = a[i];
    ak = i[a];


Передача массива в функцию
==========================

Для работы с массивом внутри функции требуется передавать в качестве аргументов адрес массива и количество элементов. Так как в функцию передается адрес массива, то все изменения элементов этого массива будут видны извне.

Дан массив. Поменяем наибольший элемент массива с первым.

Пример №2
---------

.. code-block:: c

    #include <stdio.h>

    // Функция обмена
    void change(int* x, int n)
    {
        // x - указатель на массив (адрес массива)
        // n - размер массива
        int max = x[0], index = 0;
        // Поиск максимального элемента
        for (int i = 1; i < n; ++i)
        {
            if (x[i] > max)
            {
                max = x[i];
                index = i;
            }
        }
        // Обмен
        x[index] = x[0];
        x[0] = max;
    }

    int main()
    {
        int a[10];
        for (int i = 0; i < 10; i++)
        {
            printf("a[%d] = ", i);
            scanf("%d", &a[i]);
        }
        change(a, 10); // вызов функции обмена
        // Вывод элементов массива
        for (i = 0; i<10; i++)
        {
            printf("%d ", a[i]);
        }
        return 0;
    }


Пример №3
---------

.. code-block:: c

        #include <stdio.h>

        void print_array(const int a[], int size)
        {
            printf("Array: ");
            for (int i = 0; i < size; ++i)             
            {
                printf("%d ", a[i]);
            }
            printf("\n");
        }

        int main(){
                int n, *b;
                scanf("%d", &n);        // input array size
                {                       // -- begin block --

                        int a[n];       // define array inside the block

                        for (int i = 0; i < n; a[i++] = i * i); // fill array
                        print_array(a, n);                      // print array
                        b = a;  // save array address

                }                       // -- end block --

                int a;                           // define a as integer
                scanf("%d", &a);                 // input value
                printf("n = %d\n", a);            // print it
                print_array(b, n);               // print array

                return 0;
        }

Результат работы программы:

.. code-block:: bash
        
        ./app
        5
        Array: 1 4 9 16 25
        5
        n = 5
        Array: 1 4 9 3 -182291632


Как можно видеть из примера: 

#. После окончания блока переменная :c:`a` «освободилась», и её можно использовать, как переменную другого типа (:c:`int`).
#. Если память, соответствующая некоторому массиву считается свободной — нельзя гарантировать сохранность данных и корректную работу программы
#. Чтобы контролировать неизменность массива :c:`a` в процессе *компиляции*, тип первой передаваемой функции :c:`const int a[]`

Теперь рассмотрим, как передавать многомерные массивы (в частном случае - двумерные) в функцию:

Пример №4
---------

.. code-block:: c

        #include <stdlib.h>
        #include <stdio.h>

        void print2array(int  a[][4], int n)
        {
                for (int i=0; i < n; ++i) {
                        for (int j = 0; j < 4; ++j) {
                                printf("%d ", a[i][j]);
                        }
                        printf("\n");
                }
        }

        int main()
        {
                int n;
                scanf("%d ", n);
                int a[n][4];
                for (int i=0; i < n; ++i) {
                        for (int j = 0; j < 4; ++j) {
                                a[i][j] = i + j;
                        }
                };

                print2array(a, n);
                return 0;
        }


Упражнение №3
-------------

Написать функцию, вычисляющую произведение четных элементов

Динамическое выделение памяти
=============================

Для того, чтобы двигаться дальше, нужно понимать организацию памяти пользовательских процессов. Стек, куча.

.. image:: https://i.imgur.com/70lASyv.jpg
   :width: 700
   :align: center

Виртуальное адресное пространство процесса разделено на kernel space и user space. В верхней части user mode расположен стек. Стек используется для хранения локальных переменных и аргументов, переданных в функцию. Вызов функции или метода приводит к помещению в стек т.н. стекового фрейма. Когда функция возвращает управление, стековый фрейм уничтожается.

Стек в процессе работы процесса увеличивается, но до определенного константой RLIMIT_STACK ОС размера. RLIMIT_STACK часто равен 8 мб. Если при очередном добавлении данных на стек его размер выходит за RLIMIT_STACK, то происходит переполнение стека (stack overflow) - Segmentation Fault.

Куча, подобно стеку, используется для выделения памяти во время выполнения программы. В отличие от стека, память, выделенная в куче, сохранится после того, как функция, вызвавшая выделение этой памяти, завершится. Язык С предоставляет функции для работы с этой областью памяти, о которых будет сказано ниже.

Упражнение №4
-------------

Массив насколько большого размера можно создать?

.. code-block:: c

    #include <stdio.h>

    // 2 * 1000 * 1000 + 100 * 1000
    #define N (2 * 1000 * 1000)

    int main()
    {
        int a[N] = {0};
        return 0;
    }

Все дело в том, что память при создании массивов выделяется на стеке.
И здесь мы переходим к динамическому выделению памяти для хранение массива данных.

В языке **С** существует ряд функций для работы с динамическим выделением/освобождением памяти:

.. code-block:: c

    void *malloc(size_t size);
    void *calloc(size_t elements, size_t sz);
    void *realloc(void *ptr, size_t size);
    void free(void *ptr);


========  ==================================================================
Функция     Описание 
========  ==================================================================
malloc      выделяет запрашиваемое количество **байт**
realloc     уменьшает/увеличивает выделенный блок памяти
calloc      выделяет запрашиваемое количество байт и инициализирует их нулем
free        освобождает выделенный блок памяти
========  ==================================================================

При выделении памяти блоки памяти, как правило, выделяются на куче, но нужно понимать, что не всегда. При запросе выделить "очень много" памяти на линуксе начинает использоваться другой механизм (анонимное отображение в память).

Посмотрим как работать с динамическим выделением памяти:

Пример №3
---------
.. code-block:: c

    #include <stdio.h>
    #include <stdlib.h>

    int main(int argc, char* argv[])
    {
        int N;
        printf("Enter size of array to create:");
        scanf("%d", &N);

        // malloc возвращает void*, поэтому мы обязаны привести указатель к нужному типу
        char *A = (char *)malloc(N); // выделение памяти размером N байт
        if (NULL == A) // malloc возвращает NULL, если память выделить не удалось
        {
            printf("OS didn't gave memory. Exit...\n");
            exit(1);
        }
        for (int i = 0; i < N; ++i)
        {
            A[i] = i;
        }
        printf("Array A successfully created!\n");
        free(A); // мы обязаны освободить выделенную память
        A = NULL; // ! Хорошим тоном является зануление указателя после освобождения памяти
        return 0;
    }

с malloc'ом нужно быть очень осторожным. Он выделяет указанное количество байт, а не блок памяти для указанного количества элементов (для int требуется выделять N*sizeof(int) байт):

Пример №4
---------
.. code-block:: c

    #include <stdio.h>
    #include <stdlib.h> // -> calloc/malloc/realloc/free

    int main(int argc, char* argv[])
    {
        int N = 50000000;

        for (int k = 0; k < 1000; ++k)
        {
            int *A = (int *)malloc(N*sizeof(int));
            if (NULL == A)
            {
                printf("OS didn't gave memory. Exit...\n");
                exit(1);
            }
            printf("Allocate array - OK. iteration %d.\n", k);
            for (int i = 0; i < N; ++i)
            {
                A[i] = i;
            }
            free(A); // важно!
            A = NULL;
        }
        printf("Program is on finish!\n");
        return 0;
    }

Функция **calloc** позволяет одновременно занулять выделяемую память и имеет прототип, отличный от **malloc**.
Функция **realloc** позволяет изменить размер выделенной памяти (после **malloc** или **calloc**). Если запрашиваемый размер больше выделенного, то добавленная память не зануляется. Также, при вызове realloc указатель на выделенную память может измениться (выделение другого участка памяти с копированием уже существующих элементов, а не расширение существующего).

Упражнение №5
-------------

Убедиться, что при вызове realloc адрес начала блока памяти может измениться.

Утечка памяти
=============

На каждый вызов **calloc**, **malloc** необходим вызов **free**. В языке **C** очень просто допустить утечки памяти:

Пример №5
---------

.. code-block:: c

    #include <stdio.h>
    #include <stdlib.h>

    int main() {
        int *a = malloc(5 * sizeof(int));
        return 0;
    }

Проверка на утечки памяти: **Valgrind**!

Проверить программу на утечки памяти:

.. code-block:: c
    gcc -g -o app alloc_example.c
    valgrind --leak-check=full ./app

Кусок вывода:

.. code-block:: c
    ==14222== HEAP SUMMARY:
    ==14222==     in use at exit: 10 bytes in 1 blocks
    ==14222==   total heap usage: 1 allocs, 0 frees, 10 bytes allocated
    ==14222== 
    ==14222== 10 bytes in 1 blocks are definitely lost in loss record 1 of 1
    ==14222==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
    ==14222==    by 0x10865B: main (app.c:5)
    ==14222== 
    ==14222== LEAK SUMMARY:
    ==14222==    definitely lost: 10 bytes in 1 blocks
    ==14222==    indirectly lost: 0 bytes in 0 blocks
    ==14222==      possibly lost: 0 bytes in 0 blocks
    ==14222==    still reachable: 0 bytes in 0 blocks
    ==14222==         suppressed: 0 bytes in 0 blocks

Упражнение №6
-------------

Запустить программу под valgrind (с утечкой памяти и без).


Выделение памяти под двумерные массивы
======================================

Динамическое выделение памяти под двумерный массив выполняется в две стадии:

1) Выделение памяти под массив указателей ( ~ столбцы)
2) Выделение блоков памяти под одномерные массивы, представляющие собой строки искомой матрицы

Описанная схема в виде изображения:

.. image:: https://i.imgur.com/5kwXRVN.png
   :width: 400
   :align: center

.. image:: https://i.imgur.com/FprM0sc.png
   :width: 400
   :align: center

Пример №6
---------

.. code-block:: c

    #include <stdio.h>
    #include <stdlib.h>

    int main()
    {
        int **a; // указатель на указатель на строку элементов
        int n, m;
        printf("Введите количество строк: ");
        scanf("%d", &n);
        printf("Введите количество столбцов: ");
        scanf("%d", &m);
        // Выделение памяти под указатели на строки
        a = (int**)malloc(n * sizeof(int*));
        // Ввод элементов массива
        for (int i = 0; i < n; i++) // цикл по строкам
        {
            // Выделение памяти под хранение строк
            a[i] = (int*)malloc(m * sizeof(int));
            for (int j = 0; j < m; j++)  // цикл по столбцам
            {
                printf("a[%d][%d] = ", i, j);
                scanf("%d", &a[i][j]);
            }
        }
        // Вывод элементов массива
        for (int i = 0; i < n; i++)  // цикл по строкам
        {
            for (int j = 0; j < m; j++)  // цикл по столбцам
            {
                printf("%5d ", a[i][j]); // 5 знакомест под элемент массива
            }
            printf("\n");
        }
        // Очистка памяти
        for (i = 0; i < n; i++)  // цикл по строкам
        {
            free(a[i]);   // освобождение памяти под строку
            a[i] = NULL;
        }
        free(a);
        a = NULL;
        return 0;
    }

Почему в функции **free** мы не указываем размер выделенной памяти?

В большинстве реализаций языка С при выделении памяти создается хидер, описывающий блок выделенной памяти с информацией - чек сумма, некоторые специальные маркеры, размер выделенного блока. При вызове **free**, функция берет размер выделенной памяти из хидера:

.. code-block:: c

     ____ The allocated block ____
    /                             \
    +--------+--------------------+
    | Header | Your data area ... |
    +--------+--------------------+
              ^
              |
              +-- The address you are given

Упражнение №6
-------------

Скалярное произведение 2 векторов. Ввод: В 1 строке n - длина векторов, во 2 и 3 строках - 2 вектора соответственно. Вывод: Скалярное произведение.

Метод ускоренного выделения памяти
==================================

.. code-block:: c
    int n = 2, m = 3;
    int** a = (int**)malloc(n * sizeof(int*) + n * m * sizeof(int));
    a[0] = a + n;
    for (int i = 1; i < n; ++i) {
        a[i] = a[i-1] + m;
    }


Дополнительные материалы
========================

1) Как пользоваться Valgrind: http://valgrind.org/docs/manual/quick-start.html
2) Работа с динамическим выделением памяти: https://en.wikipedia.org/wiki/C_dynamic_memory_allocation
3) Организация памяти процесса: https://habr.com/company/smart_soft/blog/185226
3) Динамические двумерные массивы: https://server.179.ru/tasks/cpp/total/086.html
