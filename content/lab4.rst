Массивы в С. Динамические массивы, malloc, realloc, free.
#####################################################################

:date: 2018-09-22 10:00
:summary: Массивы в С. Динамические массивы, malloc, realloc, free. Fast ISQRT
:status: published
:published: yes

.. default-role:: code

.. contents:: Содержание


Одномерные массивы в **С**
==========================

Массив — это непрерывный участок памяти, содержащий последовательность элементов одинакового типа, обозначаемый одним именем.

.. code-block:: c

        // Синтаксис: type arrayName[arraySize];
        int numbers[6]; // объявление массива из 6 элементов типа int
        int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // массив a из 10 чисел типа int
        int b[10] = {1};
        char ch[]  = {'a', 'r', 'r', 'a', 'y'}; // массив из char
        char ch2[] = "array"; // так тоже возможно, но это не то же, что выше! '\0'
        
        // Обращение к элементам массива
        int a0 = a[0]; // индексирование с 0
        int b9 = b[9]; // b9 становится равным последнему элементу массива
        
        // Проверка выхода за границы не гарантируется!
        int elem = a[-1];
        elem = a[20];
        elem = a[10];

        // Количество элементов массива
        int an_array[] = {0, 1, 2, 3}
        int array_count = sizeof(an_array) / sizeof(int) // array_count = 4

В 1 случае мы лишь резервируем область памяти под массив без инициализации. В 3 случае происходит инициализация по следующему правилу - если количество инициализируемых элементов меньше размера массива, оставшиеся элементы равны 0. В данном случае первый элемент массива равен 1, остальные проинициализированы 0 (удобно использовать запись "int b[10] = {0}" для обнуления элементов массива).

При создании массива выделяется непрерывная последовательность байт под массив:

.. image:: https://i.imgur.com/FEjXcJr.png
   :width: 500
   :align: center

Представленный на рисунке массив содержит q элементов с индексами от 0 до q-1. Каждый элемент занимает в памяти компьютера k байт.

Пример работы с одномерным массивом (Записываем значения в массив с клавиатуры, а затем распечатываем их):

Пример 1
--------

.. code-block:: c

    #include <stdio.h>
    
    int main()
    {
        int a[5]; // объявлен массив a из 5 элементов
        // Ввод элементов массива
        for (int i = 0; i < 5; i++) 
        {
            printf("a[%d] = ", i);
            scanf("%d", &a[i]); // &a[i] - адрес i-го элемента массива
        }
        // Вывод элементов массива
        for (i = 0; i<5; i++)
        {
            printf("%d ", a[i]);
        }
        return 0;
    }

Упражнение №1
-------------

Напишите программу, которая создаст массив с первыми N = 20 числами Фибоначчи

Многомерные массивы
==========================

В С существуют также и многомерные массивы:

.. code-block:: c

    // создание массива
    char two_d[3][5];
    
    // доступ к элементам
    char ch = two_d[2][4];
    
    // по аналогии с одномерным массивом можно проинициализировать 2-мерный
    // в такой записи мы могли бы опустить первую размерность (2), но обязаны указывать последние
    int two_d[2][3] = {{ 5, 2, 1 },
                       { 6, 7, 8 }}
    // или даже так:
    int two_d2[2][3] = {1, 2, 3, 4, 5, 6};

Для лучшего понимания последней записи, рассмотрим как многомерные массивы расположены в памяти:

.. code-block:: c

    int32_t a[2][3];


.. image:: https://i.imgur.com/b5CcEE8.png
   :width: 500
   :align: center

Общее количество элементов в приведенном двумерном массиве определится как
КоличествоСтрок * КоличествоСтолбцов = 2 * 3 = 6.
Количество байт памяти, требуемых для размещения массива, определится как
КоличествоЭлементов * РазмерЭлемента = 6 * 4 = 24 байта.

Упражнение №2
-------------

Напишите программу, перемножающую матрицы A(2x3), B(3x2).

Связь между массивами и указателями:

.. code-block:: c

    int a[] = {1, 2, 3};
    
    // обращение к 0 элементу:
    int a0 = a[0];
    a0 = *a;

    int k = 2;
    // обращение к k-ому элементу (две записи абсолютно эквивалентны):
    int ak = a[k];
    ak = *(a+k);

    // *(a+k) == *(k+a), а это значит, что язык позволяет писать даже так:
    ak = a[i];
    ak = i[a];


Передача массива в функцию
==========================

Для работы с массивом внутри функции требуется передавать в качестве аргументов адрес массива и количество элементов. Так как в функцию передается адрес массива, то все изменения элементов этого массива будут видны извне.

Дан массив. Поменяем наибольший элемент массива с первым.

Пример 2
--------
.. code-block:: c

    #include <stdio.h>

    // Функция обмена
    void change(int* x, int n)
    {
        // x - указатель на массив (адрес массива)
        // n - размер массива
        int max = x[0], index = 0;
        // Поиск максимального элемента
        for (int i = 1; i < n; ++i)
        {
            if (x[i] > max)
            {
                max = x[i];
                index = i;
            }
        }
        // Обмен
        x[index] = x[0];
        x[0] = max;
    }

    int main()
    {
        int a[10];
        for (int i = 0; i < 10; i++)
        {
            printf("a[%d] = ", i);
            scanf("%d", &a[i]);
        }
        change(a, 10); // вызов функции обмена
        // Вывод элементов массива
        for (i = 0; i<10; i++)
        {
            printf("%d ", a[i]);
        }
        return 0;
    }

Упражнение №3
-------------

Написать функцию, вычисляющую произведение четных элементов

Динамическое выделение памяти
=============================

Для того, чтобы двигаться дальше, нужно понимать организацию памяти пользовательских процессов. Стек, куча.

.. image:: https://i.imgur.com/70lASyv.jpg
   :width: 700
   :align: center

Виртуальное адресное пространство процесса разделено на kernel space и user space. В верхней части user mode расположен стек. Стек используется для хранения локальных переменных и аргументов, переданных в функцию. Вызов функции или метода приводит к помещению в стек т.н. стекового фрейма. Когда функция возвращает управление, стековый фрейм уничтожается.

Стек в процессе работы процесса увеличивается, но до определенного константой RLIMIT_STACK ОС размера. RLIMIT_STACK часто равен 8 мб. Если при очередном добавлении данных на стек его размер выходит за RLIMIT_STACK, то происходит переполнение стека (stack overflow) - Segmentation Fault.

Куча, подобно стеку, используется для выделения памяти во время выполнения программы. В отличие от стека, память, выделенная в куче, сохранится после того, как функция, вызвавшая выделение этой памяти, завершится. Язык С предоставляет функции для работы с этой областью памяти, о которых будет сказано ниже.

Упражнение N4
-------------

Массив насколько большого размера можно создать?

.. code-block:: c

    #include <stdio.h>

    // 2 * 1000 * 1000 + 100 * 1000
    #define N (2 * 1000 * 1000)

    int main()
    {
        int a[N] = {0};
        return 0;
    }

Все дело в том, что память при создании массивов выделяется на стеке.
И здесь мы переходим к динамическому выделению памяти для хранение массива данных.

В языке **С** существует ряд функций для работы с динамическим выделением/освобождением памяти:

.. code-block:: c

    void *malloc(size_t size);
    void *calloc(size_t elements, size_t sz);
    void *realloc(void *ptr, size_t size);
    void free(void *ptr);


========  ==================================================================
Функция     Описание 
========  ==================================================================
malloc      выделяет запрашиваемое количество **байт**
realloc     уменьшает/увеличивает выделенный блок памяти
calloc      выделяет запрашиваемое количество байт и инициализирует их нулем
free        освобождает выделенный блок памяти
========  ==================================================================

При выделении памяти блоки памяти, как правило, выделяются на куче, но нужно понимать, что не всегда. При запросе выделить "очень много" памяти на линуксе начинает использоваться другой механизм (анонимное отображение в память).

Посмотрим как работать с динамическим выделением памяти:

Пример 3
--------
.. code-block:: c

    #include <stdio.h>
    #include <stdlib.h>

    int main(int argc, char* argv[])
    {
        int N;
        printf("Enter size of array to create:");
        scanf("%d", &N);

        // malloc возвращает void*, поэтому мы обязаны привести указатель к нужному типу
        char *A = (char *)malloc(N); // выделение памяти размером N байт
        if (NULL == A) // malloc возвращает NULL, если память выделить не удалось
        {
            printf("OS didn't gave memory. Exit...\n");
            exit(1);
        }
        for (int i = 0; i < N; ++i)
        {
            A[i] = i;
        }
        printf("Array A successfully created!\n");
        free(A); // мы обязаны освободить выделенную память
        return 0;
    }

с malloc'ом нужно быть очень осторожным. Он выделяет указанное количество байт, а не блок памяти для указанного количества элементов (для int требуется выделять N*sizeof(int) байт):

Пример 4
------------
.. code-block:: c

    #include <stdio.h>
    #include <stdlib.h> // -> calloc/malloc/realloc/free

    int main(int argc, char* argv[])
    {
        int N = 50000000;

        for (int k = 0; k < 1000; ++k)
        {
            int *A = (int *)malloc(N*sizeof(int));
            if (NULL == A)
            {
                printf("OS didn't gave memory. Exit...\n");
                exit(1);
            }
            printf("Allocate array - OK. iteration %d.\n", k);
            for (int i = 0; i < N; ++i)
            {
                A[i] = i;
            }
            free(A); // важно!
        }
        printf("Program is on finish!\n");
        return 0;
    }

Функция **calloc** позволяет одновременно занулять выделяемую память и имеет прототип, отличный от **malloc**.
Функция **realloc** позволяет изменить размер выделенной памяти (после **malloc** или **calloc**). Если запрашиваемый размер больше выделенного, то добавленная память не зануляется. Также, при вызове realloc указатель на выделенную память может измениться (выделение другого участка памяти с копированием уже существующих элементов, а не расширение существующего).

Упражнение 5
------------

Убедиться, что при вызове realloc адрес начала блока памяти может измениться.

Утечка памяти
=============

На каждый вызов **calloc**, **malloc** необходим вызов **free**. В языке **C** очень просто допустить утечки памяти:

Пример 5
--------
.. code-block:: c

    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    // Danger function: it's not responsible for
    // the memory it allocates for the duplicate!
    int* duplicate_array(int *A, size_t N)
    {
        int * B = (int *) malloc(sizeof(int)*N);
        for(size_t i = 0; i < N; i++)
            B[i] = A[i];
        printf(" duplicate_array() allocated memory for the duplicate.\n");
        return B;
    }

    int main()
    {
        printf("Calling irresponsible function duplicate_array():\n");
        int A[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int *B = duplicate_array(A, 10);
        for (int i = 0; i < 10; ++i)
            printf("%d\t", B[i]);

        printf("Since caller function is not taking responsibility by itself,\n");
        printf(" memory for the array above will never be released...\n\n");

        printf("The same situation for the standard function strdup():\n");
        char *hello = "Hello, World!";
        char *message = strdup(hello);
        printf("Strdup allocated memory for this message: \"%s\"\n", message);
        printf("It'll never be released...\n\n");

        int *p;
        for (int i = 0; i < 10; i++)
        {
            p = (int *)malloc(sizeof(int));
            printf("Allocating memory many times in cycle.\n");
            *p = i;
        }
        free(p);
        printf("But releasing it just once...\n");

        return 0;
    }

Проверка на утечки памяти: **Valgrind**.

Выделение памяти под двумерные массивы
======================================

Динамическое выделение памяти под двумерный массив выполняется в две стадии:

1) Выделение памяти под массив указателей ( ~ столбцы)
2) Выделение блоков памяти под одномерные массивы, представляющие собой строки искомой матрицы

Описанная схема в виде изображения:

.. image:: https://i.imgur.com/5kwXRVN.png
   :width: 400
   :align: center

.. image:: https://i.imgur.com/FprM0sc.png
   :width: 400
   :align: center

Пример 6
--------
.. code-block:: c

    #include <stdio.h>
    #include <stdlib.h>

    int main()
    {
        int **a; // указатель на указатель на строку элементов
        int n, m;
        printf("Введите количество строк: ");
        scanf("%d", &n);
        printf("Введите количество столбцов: ");
        scanf("%d", &m);
        // Выделение памяти под указатели на строки
        a = (int**)malloc(n * sizeof(int*));
        // Ввод элементов массива
        for (int i = 0; i < n; i++) // цикл по строкам
        {
            // Выделение памяти под хранение строк
            a[i] = (int*)malloc(m * sizeof(int));
            for (int j = 0; j < m; j++)  // цикл по столбцам
            {
                printf("a[%d][%d] = ", i, j);
                scanf("%d", &a[i][j]);
            }
        }
        // Вывод элементов массива
        for (int i = 0; i < n; i++)  // цикл по строкам
        {
            for (int j = 0; j < m; j++)  // цикл по столбцам
            {
                printf("%5d ", a[i][j]); // 5 знакомест под элемент массива
            }
            printf("\n");
        }
        // Очистка памяти
        for (i = 0; i < n; i++)  // цикл по строкам
        {
            free(a[i]);   // освобождение памяти под строку
        }
        free(a);
        return 0;
    }

Почему в функции **free** мы не указываем размер выделенной памяти?

В большинстве реализаций языка С при выделении памяти создается хидер, описывающий блок выделенной памяти с информацией - чек сумма, некоторые специальные маркеры, размер выделенного блока. При вызове **free**, функция берет размер выделенной памяти из хидера:

.. code-block:: c

     ____ The allocated block ____
    /                             \
    +--------+--------------------+
    | Header | Your data area ... |
    +--------+--------------------+
              ^
              |
              +-- The address you are given

Упражнение 6
------------

Скалярное произведение 2 векторов. Ввод: В 1 строке n - длина векторов, во 2 и 3 строках - 2 вектора соответственно. Вывод: Скалярное произведение.
